<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoE2 Modifier Overlay</title>
    <link rel="stylesheet" href="./styles/overlay.css">
    <script type="module" src="./overlay-entry.ts"></script>

        <style>
            /* Login / Logout button state styles */
            #poeLoginBtn.login-state { background:#1e5eb8; color:#fff; border:1px solid #2d74d6; }
            #poeLoginBtn.login-state:hover { background:#256bd1; }
            #poeLoginBtn.logout-state { background:#7d1d1d; color:#fff; border:1px solid #a22828; }
            #poeLoginBtn.logout-state:hover { background:#942424; }
            /* Ensure native select dropdown text is readable on dark theme */
            select.sel-currency, select.sel-time, select.sel-sort, select.sel-rarity, select.sel-type {
                color: var(--text-primary);
            }
            select.sel-currency option,
            select.sel-time option,
            select.sel-sort option,
            select.sel-rarity option,
            select.sel-type option { background: var(--bg-tertiary); color: var(--text-primary); }
        </style>
</head>
<body>
    <!-- App header -->
    <div id="mainHeader" class="header" style="background: var(--bg-secondary); padding: 8px 12px; border-bottom: 1px solid var(--border-color); display:flex; align-items:center; gap:8px; -webkit-app-region: drag; flex: 0 0 auto;">
        <div class="item-info">
            <div class="item-name" id="headerTitle" style="font-weight:600; font-size:14px; user-select:none;">Modifier</div>
            <div class="item-type" id="headerSubtitle" style="font-size:12px; color:var(--text-muted); user-select:none;"></div>
        </div>
        <!-- Modifier info badges (shown on modifiers tab) -->
        <div id="modifierHeaderInfo" style="display:none; margin-left:8px; -webkit-app-region: no-drag;"></div>
        <div id="whittlingInfo" style="display:none; margin-right:8px; -webkit-app-region: no-drag;"></div>
        <!-- Merchant header (shown only on History tab) -->
        <div id="historyHeaderMain" style="flex:1 1 auto; min-width:0; align-items:center; gap:8px; justify-content:space-between; display:flex; -webkit-app-region: drag;">
            <div style="display:flex; align-items:center; gap:6px; flex-wrap:wrap;">
                <button id="poeLoginBtn" class="pin-btn login-state" style="-webkit-app-region: no-drag;" title="Login to pathofexile.com">Login</button>
                <button id="historyRefreshBtn" class="pin-btn" style="-webkit-app-region: no-drag;" title="Refresh history">Refresh</button>
                <button id="historyPopoutBtn" class="pin-btn" style="-webkit-app-region: no-drag;" title="Pop out history">ðŸ“Œ</button>
                <span id="historyInfoBadge" class="price-badge" style="display:none;">Info</span>
            </div>
            <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                <div id="historyTotals" style="display:flex; gap:6px; flex-wrap:wrap;"></div>
                <span id="historyTradeCount" style="color:var(--text-secondary); font-size:11px;"></span>
            </div>
        </div>
        <div class="header-actions" style="display:flex; align-items:center; gap:6px; margin-left:auto; -webkit-app-region: no-drag; user-select:none;">
            <button id="pinBtn" class="pin-btn" title="Pin overlay on top">Pin</button>
            <button id="closeBtn" class="close-btn" title="Close overlay">Ã—</button>
        </div>
    </div>
    <div id="app" style="display:flex; flex-direction:column; flex:1 1 auto; min-height:0;">
    <div id="controlPanel" class="control-panel" style="-webkit-app-region: no-drag;">
        <div class="cp-left" style="display:flex; align-items:center; gap:6px; flex:0 0 auto;">
            <label class="cp-label" style="font-size:11px; color:var(--text-secondary);">Category</label>
            <select id="categorySelect" class="cp-select" style="min-width:140px;"></select>
        </div>
    <input id="search-input" class="cp-search" type="text" placeholder="Search..." style="width:150px; flex:0 0 auto;" />
    <div style="display:flex; align-items:center; gap:4px; flex:0 0 auto; white-space:nowrap;">
            <label style="font-size:11px; color:var(--text-secondary);">iLvl</label>
            <input id="ilvl-min" type="number" min="0" placeholder="min" style="width:50px; padding:3px 4px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px;" />
            <span style="color:var(--text-secondary); font-size:11px;">-</span>
            <input id="ilvl-max" type="number" min="0" placeholder="max" style="width:50px; padding:3px 4px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px;" />
        </div>
    <div id="domainFilters" class="cp-filters" style="display:flex; align-items:center; gap:4px; flex:0 0 auto; white-space:nowrap;">
            <span class="cp-filters-label" style="font-size:11px; color:var(--text-secondary);">Show:</span>
            <button id="toggleAll" class="domain-toggle active" data-domain="all">All</button>
            <button id="toggleBase" class="domain-toggle" data-domain="base">Base</button>
            <button id="toggleDesecrated" class="domain-toggle" data-domain="desecrated">Dese</button>
            <button id="toggleEssence" class="domain-toggle" data-domain="essence">Ess</button>
            <button id="toggleCorrupted" class="domain-toggle" data-domain="corrupted">Corr</button>
        </div>
    <button id="clearFilters" class="pin-btn cp-clear" style="margin-left:auto; flex:0 0 auto;">Clear</button>
        </div>
    <div id="content" style="flex:1 1 auto; overflow:auto; padding:16px 12px 12px 12px;">
            <div class="no-mods">Pick a category from the dropdown to load modifiers.</div>
        </div>
    <div id="craftingPanel" style="display:none; position:relative; flex:1 1 auto; overflow:auto; padding:16px 12px 12px 12px;"></div>
        <!-- History view container (hidden by default, toggled by Merchant History tab) -->
    <!-- History container (normal flow, visibility controlled by data-view) -->
    <div id="historyContainer" style="display:none; flex:1 1 auto; overflow:hidden;">
            <!-- History header/filters -->
                        <div id="historyHeader" style="display:flex; flex-direction:column; gap:2px; padding:4px 8px 2px 8px; border-bottom:1px solid var(--border-color); background: var(--bg-secondary); -webkit-app-region: no-drag;">
                            <div id="historyHeaderRow2" style="display:flex; flex-direction:row; align-items:center; gap:8px; flex-wrap:nowrap; overflow:hidden;">
                                <div class="fgrp grp-currency" style="display:flex; align-items:center; gap:4px;">
                                    <label style="color:var(--text-secondary); font-size:11px;">Currency:</label>
                                      <select id="histCurrency" class="sel-currency" style="padding:3px 6px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px; appearance:none;">
                                        <option value="">All</option>
                                        <option value="exalted">Exalted</option>
                                        <option value="divine">Divine</option>
                                        <option value="annul">Annul</option>
                                        <option value="chaos">Chaos</option>
                                        <option value="regal">Regal</option>
                                    </select>
                                </div>
                                <div class="fgrp grp-time" style="display:flex; align-items:center; gap:4px;">
                                    <label style="color:var(--text-secondary); font-size:11px;">Time:</label>
                                      <select id="histTimeframe" class="sel-time" style="padding:3px 6px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px; appearance:none;">
                                        <option value="all" selected>All</option>
                                        <option value="today">Today</option>
                                        <option value="yesterday">Yesterday</option>
                                        <option value="7d">7D</option>
                                        <option value="14d">14D</option>
                                        <option value="30d">30D</option>
                                    </select>
                                </div>
                                <div class="fgrp grp-sort" style="display:flex; align-items:center; gap:4px;">
                                    <label style="color:var(--text-secondary); font-size:11px;">Sort:</label>
                                      <select id="histSort" class="sel-sort" style="padding:3px 6px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px; appearance:none;">
                                        <option value="newest">Newest</option>
                                        <option value="oldest">Oldest</option>
                                        <option value="divine-desc">Highest Divine</option>
                                        <option value="divine-asc">Lowest Divine</option>
                                        <option value="exalted-desc">Highest Exalted</option>
                                        <option value="exalted-asc">Lowest Exalted</option>
                                        <option value="chaos-desc">Highest Chaos</option>
                                        <option value="chaos-asc">Lowest Chaos</option>
                                        <option value="regal-desc">Highest Regal</option>
                                        <option value="regal-asc">Lowest Regal</option>
                                    </select>
                                </div>
                                <div class="fgrp grp-rarity" style="display:flex; align-items:center; gap:4px;">
                                    <label style="color:var(--text-secondary); font-size:11px;">Rarity:</label>
                                      <select id="histRarity" class="sel-rarity" style="padding:3px 6px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px; appearance:none;">
                                        <option value="">All</option>
                                        <option value="Normal">Normal</option>
                                        <option value="Magic">Magic</option>
                                        <option value="Rare">Rare</option>
                                        <option value="Unique">Unique</option>
                                        <option value="Foil">Foil</option>
                                    </select>
                                </div>
                                <div class="fgrp grp-type" style="display:flex; align-items:center; gap:4px;">
                                    <label style="color:var(--text-secondary); font-size:11px;">Type:</label>
                                      <select id="histCategory" class="sel-type" style="padding:3px 6px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px; appearance:none;">
                                        <option value="">All</option>
                                        <option>Helmets</option>
                                        <option>Body Armours</option>
                                        <option>Gloves</option>
                                        <option>Boots</option>
                                        <option>Offhand</option>
                                        <option>Rings</option>
                                        <option>Amulets</option>
                                        <option>Belts</option>
                                        <option>Weapons</option>
                                        <option>Jewels</option>
                                        <option>Other</option>
                                    </select>
                                </div>
                                <div class="fgrp grp-search" style="display:flex; align-items:center; gap:4px;">
                                    <input id="histSearch" class="inp-search" type="text" placeholder="Search items..." style="width:220px; padding:3px 8px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:6px; color:var(--text-primary); font-size:11px;" />
                                </div>
                            </div>
                            <div id="historyActiveFilters" style="display:flex; gap:6px; flex-wrap:wrap;"></div>
                        </div>
            <!-- History body (list + details + chart) -->
            <div style="display:flex; flex:1 1 auto; min-height:0;">
            <!-- Left list -->
            <div id="historyList" style="flex: 0 0 55%; border-right:1px solid var(--border-color); overflow-y:auto; min-height:0;">
                <!-- rows injected here -->
            </div>
            <!-- Right details -->
            <div id="historyRight" style="flex: 1 1 auto; display:flex; flex-direction:column; overflow:hidden; min-height:0;">
                <div id="historyDetail" style="flex: 0 1 auto; overflow-y:auto; padding: 10px; display:flex; align-items:flex-start; justify-content:center; min-height:0;">
                    <div class="no-mods">Select a trade to see item details</div>
                </div>
                <div id="historyChartWrap" style="flex: 1 1 auto; border-top:1px solid var(--border-color); padding:8px; background: var(--bg-card); min-height:140px; transition: all 0.3s ease;">
                    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:4px;">
                        <div style="display:flex; align-items:center; gap:8px;">
                            <button id="chartCollapseBtn" title="Collapse/Expand chart" style="padding:2px 6px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-secondary); cursor:pointer; font-size:11px; font-weight:bold;">â–¼</button>
                            <button id="chartExpandBtn" title="Expand chart to take full space" style="padding:2px 6px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-secondary); cursor:pointer; font-size:11px; font-weight:bold;">â–²</button>
                            <div style="font-weight:600; color:var(--text-secondary);">Totals over time</div>
                        </div>
                        <div style="display:flex; gap:10px; align-items:center; font-size:11px;">
                            <span id="chartCur-divine" class="chart-cur active" data-cur="divine"><span class="sw" style="background:#d4af37;"></span> divine</span>
                            <span id="chartCur-exalted" class="chart-cur" data-cur="exalted"><span class="sw" style="background:#3f6aa1;"></span> exalted</span>
                            <span id="chartCur-annul" class="chart-cur" data-cur="annul"><span class="sw" style="background:#7b40b3;"></span> annul</span>
                            <span id="chartCur-chaos" class="chart-cur" data-cur="chaos"><span class="sw" style="background:#4a6a35;"></span> chaos</span>
                            <span id="chartCur-regal" class="chart-cur" data-cur="regal"><span class="sw" style="background:#6b4a28;"></span> regal</span>
                        </div>
                    </div>
                    <canvas id="historyChart" height="150" style="width:100%; min-width:240px; display:block;"></canvas>
                </div>
            </div>
            </div>
        </div>
    </div>
    </div>

    <!-- Footer with tabs and resize handle -->
    <div class="footer" id="footer" style="background: var(--bg-secondary); border-top: 1px solid var(--border-color); padding: 4px 8px; display: flex; align-items: center; justify-content: space-between; -webkit-app-region: drag; flex: 0 0 auto;">
        <div class="tabs" style="display: flex; gap: 8px; -webkit-app-region: no-drag;">
            <button id="tabModifier" class="tab active" style="background: var(--accent-blue); color: #fff; border: 1px solid var(--accent-blue); border-radius: 4px; padding: 3px 8px; font-size: 12px; display:inline-flex; align-items:center; gap:4px;">
                <span class="menu-icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="7" height="7"></rect>
                        <rect x="14" y="3" width="7" height="7"></rect>
                        <rect x="14" y="14" width="7" height="7"></rect>
                        <rect x="3" y="14" width="7" height="7"></rect>
                    </svg>
                </span>
                <span>Modifier</span>
            </button>
            <div class="tab" id="craftingTab" style="position:relative; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px; cursor:pointer; display:inline-flex; align-items:center; gap:4px;">
                <span class="menu-icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 2l3 7h7l-5.5 4.1L18 21l-6-4-6 4 1.5-7.9L2 9h7z" />
                    </svg>
                </span>
                <span>Crafting â–¾</span>
                <div id="craftingMenu" style="display:none; position:absolute; left:0; bottom:100%; transform: translateY(-4px); background: var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; min-width:160px; box-shadow:0 2px 6px rgba(0,0,0,0.4); z-index:200;">
                    <div class="crafting-menu-item" data-action="liquid-emotions" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2C9 7 7 9.5 7 13a5 5 0 0010 0c0-3.5-2-6-5-11z"/></svg></span>
                        <span>Liquid Emotions</span>
                    </div>
                    <div class="crafting-menu-item" data-action="annoints" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 20l4-9 4 4 8-12" /><path d="M2 4h6"/></svg></span>
                        <span>Annoints</span>
                    </div>
                    <div class="crafting-menu-item" data-action="essences" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l6 6-6 14-6-14 6-6z"/></svg></span>
                        <span>Essences</span>
                    </div>
                    <div class="crafting-menu-item" data-action="omens" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4" /><path d="M2 12h2M20 12h2M12 2v2M12 20v2M4.9 4.9l1.4 1.4M17.7 17.7l1.4 1.4M19.1 4.9l-1.4 1.4M6.3 17.7l-1.4 1.4"/></svg></span>
                        <span>Omens</span>
                    </div>
                    <div class="crafting-menu-item" data-action="currency" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="8" cy="12" r="3"/><circle cx="16" cy="12" r="3"/><path d="M8 9V5m0 14v-4m8-6V5m0 14v-4"/></svg></span>
                        <span>Currency</span>
                    </div>
                    <div class="crafting-menu-item" data-action="catalysts" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3 5-3 5-3-5 3-5z"/><path d="M5 19h14"/><path d="M5 15h14"/></svg></span>
                        <span>Catalysts</span>
                    </div>
                    <div class="crafting-menu-item" data-action="socketables" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="8" width="7" height="8" rx="1"/><rect x="14" y="5" width="7" height="14" rx="1"/></svg></span>
                        <span>Socketables</span>
                    </div>
                        </div>
            </div>
            <div class="tab" id="characterTab" style="position:relative; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px; cursor:pointer; display:inline-flex; align-items:center; gap:4px;">
                <span class="menu-icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="7" r="4"/><path d="M5.5 21a6.5 6.5 0 0113 0"/></svg></span>
                <span>Character â–¾</span>
                <div id="characterMenu" style="display:none; position:absolute; left:0; bottom:100%; transform: translateY(-4px); background: var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; min-width:160px; box-shadow:0 2px 6px rgba(0,0,0,0.4); z-index:250;">
                    <div class="character-menu-item" data-action="quest-passives" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16v4H4z"/><path d="M4 12h16v8H4z"/></svg></span>
                        <span>Quest Passives</span>
                    </div>
                    <div class="character-menu-item" data-action="keystones" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l7 4v6c0 5-3 8-7 10-4-2-7-5-7-10V6l7-4z"/></svg></span>
                        <span>Keystones</span>
                    </div>
                    <div class="character-menu-item" data-action="asc-passives" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/></svg></span>
                        <span>Ascendancy Passives</span>
                    </div>
                    <div class="character-menu-item" data-action="atlas-nodes" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3" /><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 01-2.83 2.83l-.06-.06A1.65 1.65 0 0015 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0l-.06-.06A1.65 1.65 0 008.6 19.4a1.65 1.65 0 00-1.82-.33l-.06.06a2 2 0 01-2.83-2.83l.06-.06A1.65 1.65 0 004.6 15a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06A1.65 1.65 0 008.6 9a1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0l.06.06A1.65 1.65 0 0015 9a1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06A1.65 1.65 0 0019.4 13c0 .4.16.78.44 1.06z"/></svg></span>
                        <span>Atlas Nodes</span>
                    </div>
                    <div class="character-menu-item" data-action="gems" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 3h12l3 6-9 12L3 9l3-6z"/><path d="M3 9h18"/><path d="M12 3l-3 6 3 12 3-12-3-6z"/></svg></span>
                        <span>Gems</span>
                    </div>
                    <div class="character-menu-item" data-action="glossar" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 016.5 17H20"/><path d="M4 4.5A2.5 2.5 0 016.5 7H20"/><path d="M6.5 7v10"/><path d="M12 7v10"/><path d="M17.5 7v10"/></svg></span>
                        <span>Glossar</span>
                    </div>
                </div>
            </div>
            <div class="tab" id="itemsTab" style="position:relative; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px; cursor:pointer; display:inline-flex; align-items:center; gap:4px;">
                <span class="menu-icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg></span>
                <span>Items â–¾</span>
                <div id="itemsMenu" style="display:none; position:absolute; left:0; bottom:100%; transform: translateY(-4px); background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; padding:4px; z-index:300; min-width:140px; box-shadow:0 4px 14px rgba(0,0,0,0.5);">
                    <div class="items-menu-item" data-action="uniques" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l4 4-4 4-4-4 4-4z"/><path d="M12 14l4 4-4 4-4-4 4-4z"/><path d="M2 12l4-4 4 4-4 4-4-4z"/><path d="M14 12l4-4 4 4-4 4-4-4z"/></svg></span>
                        <span>Uniques</span>
                    </div>
                    <div class="items-menu-item" data-action="bases" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16" rx="2"/></svg></span>
                        <span>Bases</span>
                    </div>
                </div>
            </div>
            <div class="tab" id="toolsTab" style="position:relative; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px; cursor:pointer; display:inline-flex; align-items:center; gap:4px;">
                <span class="menu-icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 01-2.83 2.83l-.06-.06A1.65 1.65 0 0015 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0l-.06-.06A1.65 1.65 0 008.6 19.4a1.65 1.65 0 00-1.82-.33l-.06.06a2 2 0 01-2.83-2.83l.06-.06A1.65 1.65 0 004.6 15a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06A1.65 1.65 0 008.6 9a1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0l.06.06A1.65 1.65 0 0015 9a1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06A1.65 1.65 0 0019.4 13c0 .4.16.78.44 1.06z"/></svg></span>
                <span>Tools â–¾</span>
                <div id="toolsMenu" style="display:none; position:absolute; left:0; bottom:100%; transform: translateY(-4px); background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; padding:4px; z-index:320; min-width:140px; box-shadow:0 4px 14px rgba(0,0,0,0.55);">
                    <div class="tools-menu-item" data-action="regex" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3l4 4-4 4"/><path d="M3 7h18"/><path d="M7 21l-4-4 4-4"/><path d="M21 17H3"/></svg></span>
                        <span>Regex</span>
                    </div>
                </div>
            </div>
            <button id="tabHistory" class="tab" style="background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px; display:inline-flex; align-items:center; gap:4px;">
                <span class="menu-icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h18v4H3z"/><path d="M3 11h18v10H3z"/><path d="M8 7v14"/><path d="M16 7v14"/></svg></span>
                <span>Merchant History</span>
            </button>
        </div>
        <div id="resizeHandle" title="Resize height" style="height: 12px; cursor: ns-resize; display: flex; align-items: center; justify-content: center; gap:2px; padding: 0 6px; -webkit-app-region: no-drag;">
            <span style="display:inline-block; width: 14px; height: 2px; background: var(--text-muted);"></span>
            <span style="display:inline-block; width: 14px; height: 2px; background: var(--text-muted);"></span>
        </div>
    </div>

    <script>

    // Query commonly used elements (guard undefined usage)
    const tabMod = document.getElementById('tabModifier');
    const tabHist = document.getElementById('tabHistory');
    const craftingTab = document.getElementById('craftingTab');
    const craftingMenu = document.getElementById('craftingMenu');
    const characterTab = document.getElementById('characterTab');
    const characterMenu = document.getElementById('characterMenu');
    const itemsTab = document.getElementById('itemsTab');
    const itemsMenu = document.getElementById('itemsMenu');
    const toolsTab = document.getElementById('toolsTab');
    const toolsMenu = document.getElementById('toolsMenu');
    const historyHeader = document.getElementById('historyHeader') || null;
    const historyHeaderMain = document.getElementById('historyHeaderMain') || null;
    const filtersBar = document.getElementById('filtersBar') || null;
    const contentMod = document.getElementById('content');
    const contentHist = document.getElementById('historyContainer') || document.createElement('div');
    const loginBtn = document.getElementById('poeLoginBtn');
    const refreshBtn = document.getElementById('historyRefreshBtn');
    const pinBtn = document.getElementById('pinBtn');
    const closeBtn = document.getElementById('closeBtn');
    const headerTitleEl = document.getElementById('headerTitle');
    const headerSubtitleEl = document.getElementById('headerSubtitle');

    // Track which high-level views are allowed by the current feature configuration
    const featureAvailability = {
        modifiers: true,
        crafting: true,
        history: true
    };

    function setFeatureAvailability(flags) {
        if (!flags) return;
        if (typeof flags.modifiers === 'boolean') featureAvailability.modifiers = flags.modifiers;
        if (typeof flags.crafting === 'boolean') featureAvailability.crafting = flags.crafting;
        if (typeof flags.history === 'boolean') featureAvailability.history = flags.history;
    }

    function isViewAvailable(view) {
        if (view === 'modifiers') return !!featureAvailability.modifiers;
        if (view === 'history') return !!featureAvailability.history;
        if (view === 'crafting' || view === 'character') return !!featureAvailability.crafting;
        return true;
    }

    function pickFirstAvailableView(preferred) {
        const order = [];
        if (preferred) order.push(preferred);
        order.push('modifiers', 'crafting', 'history');
        const seen = new Set();
        for (const view of order) {
            if (seen.has(view)) continue;
            seen.add(view);
            if (view === 'modifiers' && featureAvailability.modifiers) return 'modifiers';
            if ((view === 'crafting' || view === 'character') && featureAvailability.crafting) return 'crafting';
            if (view === 'history' && featureAvailability.history) return 'history';
        }
        return null;
    }

    // === Image Path Helper ===
    // Convert imageLocal field to file:// URL for bundled images (SYNC version for templates)
    function getImagePath(item) {
        // Use new imageLocal field (clean local paths, no poedb URLs!)
        if (item.imageLocal) {
            // In development: file:///C:/Users/.../packages/overlay/bundled-images/...
            // In production: file:///C:/Program Files/.../resources/bundled-images/...
            // The path will be resolved by main process, but we can construct it client-side too
            return item.imageLocal; // Will be handled by image auto-resolver
        }
        
        // Fallback to old image field (deprecated, will be removed)
        if (item.image && item.image.startsWith('http')) {
            return item.image; // Will trigger old resolver
        }
        
        return ''; // No image available
    }

    function setHeader(title, subtitle=''){
        if (headerTitleEl) headerTitleEl.textContent = title || '';
        if (headerSubtitleEl) headerSubtitleEl.textContent = subtitle || '';
    }

    // Footer tab helpers: keep only the current tab blue
    function setActiveTab(tabId){
        const targetTab = document.getElementById(tabId);
        if (!targetTab) return;
        if (window.getComputedStyle(targetTab).display === 'none') return;
        const tabs = [
            document.getElementById('tabModifier'),
            document.getElementById('tabHistory'),
            document.getElementById('craftingTab'),
            document.getElementById('characterTab'),
            document.getElementById('itemsTab'),
            document.getElementById('toolsTab')
        ].filter(Boolean);
        tabs.forEach(t => {
            if (!t) return;
            const active = (t.id === tabId);
            t.classList.toggle('active', active);
            t.style.background = active ? 'var(--accent-blue)' : 'var(--bg-tertiary)';
            t.style.color = active ? '#fff' : 'var(--text-primary)';
            t.style.borderColor = active ? 'var(--accent-blue)' : 'var(--border-color)';
        });
    }
    function closeAllMenus(){
        const cm = document.getElementById('craftingMenu'); if (cm) cm.style.display='none';
        const ch = document.getElementById('characterMenu'); if (ch) ch.style.display='none';
        const im = document.getElementById('itemsMenu'); if (im) im.style.display='none';
        const tm = document.getElementById('toolsMenu'); if (tm) tm.style.display='none';
    }

    // Helper: show/hide Modifiers control panel
    function setControlPanelVisible(visible){
        const cpEl = document.getElementById('controlPanel');
        if (cpEl) cpEl.style.display = visible ? '' : 'none';
    }

    // Helper: ensure history is hidden when switching away from history view
    function hideHistoryView(){
        const hist = document.getElementById('historyContainer');
        const histHeader = document.getElementById('historyHeaderMain');
        if (hist) hist.style.display = 'none';
        if (histHeader) histHeader.style.display = 'none';
    }

    // Clean view switching: only one container visible at a time
    function setView(view){
        let targetView = view;
        if (view === 'modifiers' && !featureAvailability.modifiers) {
            targetView = pickFirstAvailableView('crafting');
        } else if ((view === 'crafting' || view === 'character') && !featureAvailability.crafting) {
            targetView = pickFirstAvailableView(view === 'crafting' ? 'history' : undefined);
        } else if (view === 'history' && !featureAvailability.history) {
            targetView = pickFirstAvailableView('modifiers');
        }

        if (!targetView) {
            console.warn('[View] No available view to show (feature set disabled)');
            return;
        }

        if (targetView !== view) {
            console.log(`[View] Requested "${view}" but feature disabled, falling back to "${targetView}"`);
        }
        view = targetView;
        const content = document.getElementById('content');
        const crafting = document.getElementById('craftingPanel');
        const history = document.getElementById('historyContainer');
        const histHeaderMain = document.getElementById('historyHeaderMain');
        const histFiltersHeader = document.getElementById('historyHeader');
        
        // ALWAYS remove ALL view classes first
        document.body.classList.remove('crafting-mode', 'view-history', 'view-modifiers');
        
        // ALWAYS hide ALL containers first
        if (content) content.style.display = 'none';
        if (crafting) crafting.style.display = 'none';
        if (history) history.style.display = 'none';
        // DO NOT set inline styles on history headers - let CSS handle it via body classes
        
        // Show only the requested view
        if (view === 'modifiers'){
            if (content) content.style.display = '';
            setControlPanelVisible(true);
            document.body.classList.add('view-modifiers');
            try { window.OverlayHistory?.onLeaveView?.(); } catch {}
        } else if (view === 'crafting'){
            if (crafting) { 
                crafting.style.display = 'block'; 
                crafting.innerHTML = ''; 
            }
            setControlPanelVisible(false);
            document.body.classList.add('crafting-mode');
            try { window.OverlayHistory?.onLeaveView?.(); } catch {}
        } else if (view === 'history'){
            // Show the container with inline style, but let CSS handle headers
            if (history) history.style.display = 'flex';
            setControlPanelVisible(false);
            document.body.classList.add('view-history');
            
            // DEBUG: Check what's actually happening
            setTimeout(() => {
                const container = document.getElementById('historyContainer');
                const header = document.getElementById('historyHeader');
                const headerMain = document.getElementById('historyHeaderMain');
                console.log('=== HISTORY VIEW DEBUG ===');
                console.log('Body classes:', document.body.className);
                console.log('Container:', container ? {
                    display: window.getComputedStyle(container).display,
                    visibility: window.getComputedStyle(container).visibility,
                    inlineStyle: container.style.display
                } : 'NOT FOUND');
                console.log('Header (filter bar):', header ? {
                    display: window.getComputedStyle(header).display,
                    visibility: window.getComputedStyle(header).visibility,
                    inlineStyle: header.style.display,
                    offsetHeight: header.offsetHeight,
                    offsetWidth: header.offsetWidth
                } : 'NOT FOUND');
                console.log('HeaderMain:', headerMain ? {
                    display: window.getComputedStyle(headerMain).display,
                    inlineStyle: headerMain.style.display
                } : 'NOT FOUND');
            }, 100);
            
            try { window.OverlayHistory?.onEnterView?.(); } catch {}
        }
        
        console.log('setView:', view, 'body classes:', document.body.className);
    }

    // debug logger removed

    // Global variables
    let currentData = null;
    let allSections = [];
    // ===== Delegations only; implementations live in TS modules via window.Overlay* facades =====
    // Catalysts, Socketables, Omens
    async function showCatalysts(){ if (window.OverlayCatalysts && window.OverlayCatalysts.show) { try { return await window.OverlayCatalysts.show(); } catch {} } }
    function renderCatalysts(list){ if (window.OverlayCatalysts && window.OverlayCatalysts.render) { try { return window.OverlayCatalysts.render(list); } catch {} } }
    async function showSocketables(){ if (window.OverlaySocketables && window.OverlaySocketables.show) { try { return await window.OverlaySocketables.show(); } catch {} } }
    function renderSocketables(list){ if (window.OverlaySocketables && window.OverlaySocketables.render) { try { return window.OverlaySocketables.render(list); } catch {} } }
    async function showOmens(){ if (window.OverlayOmens && window.OverlayOmens.show) { try { return await window.OverlayOmens.show(); } catch {} } }
    function renderOmens(list){ if (window.OverlayOmens && window.OverlayOmens.render) { try { return window.OverlayOmens.render(list); } catch {} } }
    async function showCurrency(){ if (window.OverlayCurrency && window.OverlayCurrency.show) { try { return await window.OverlayCurrency.show(); } catch {} } }
    function renderCurrency(list){ if (window.OverlayCurrency && window.OverlayCurrency.render) { try { return window.OverlayCurrency.render(list); } catch {} } }
    // Uniques, Bases, Glossar
    async function showUniques(){ if (window.OverlayUniques && window.OverlayUniques.show) { try { return await window.OverlayUniques.show(); } catch {} } }
    function renderUniques(groups){ if (window.OverlayUniques && window.OverlayUniques.render) { try { return window.OverlayUniques.render(groups); } catch {} } }
    async function showBases(){ if (window.OverlayBases && window.OverlayBases.show) { try { return await window.OverlayBases.show(); } catch {} } }
    function renderBases(groups){ if (window.OverlayBases && window.OverlayBases.render) { try { return window.OverlayBases.render(groups); } catch {} } }
    async function showGlossar(){ if (window.OverlayGlossar && window.OverlayGlossar.show) { try { return await window.OverlayGlossar.show(); } catch {} } }
    function renderGlossar(list){ if (window.OverlayGlossar && window.OverlayGlossar.render) { try { return window.OverlayGlossar.render(list); } catch {} } }
    // Annoints, Essences
    async function showAnnoints(){ if (window.OverlayAnnoints && window.OverlayAnnoints.show) { try { return await window.OverlayAnnoints.show(); } catch {} } }
    async function showEssences(){ if (window.OverlayEssences && window.OverlayEssences.show) { try { return await window.OverlayEssences.show(); } catch {} } }
    function renderEssences(list){ if (window.OverlayEssences && window.OverlayEssences.render) { try { return window.OverlayEssences.render(list); } catch {} } }
    // History aliases and thin wrappers
    let historyState = null;
    // Grab history state as soon as possible; refresh on DOMContentLoaded too
    try { historyState = window.OverlayHistory?.historyState || null; } catch {}
    window.addEventListener('DOMContentLoaded', () => { try { historyState = window.OverlayHistory?.historyState || historyState; } catch {} });
    async function updateSessionUI(){ return await window.OverlayHistory?.updateSessionUI?.(); }
    function keyForRow(r){ return window.OverlayHistory?.keyForRow?.(r); }
    function addToTotals(p){ return window.OverlayHistory?.addToTotalsWrapper?.(p); }
    function renderHistoryTotals(){ return window.OverlayHistory?.renderHistoryTotalsWrapper?.(); }
    function renderHistoryActiveFilters(){ return window.OverlayHistory?.renderHistoryActiveFiltersWrapper?.(); }
    function renderHistoryList(){ return window.OverlayHistory?.renderHistoryListWrapper?.(); }
    function renderHistoryDetail(i){ return window.OverlayHistory?.renderHistoryDetailWrapper?.(i); }
    function applySort(list){ return window.OverlayHistory?.applySort?.(list, window.OverlayHistory?.historyState?.sort) ?? list; }
    function applyFilters(list){ return window.OverlayHistory?.applyFilters?.(list, window.OverlayHistory?.historyState?.filters) ?? list; }
    async function refreshHistory(){ return await window.OverlayHistory?.onManualRefresh?.(); }
    function recomputeChartSeriesFromStore(){ return window.OverlayHistory?.recomputeChartSeriesFromStore?.(); }
    function updateHistoryChartFromTotals(t){ return window.OverlayHistory?.updateHistoryChartFromTotals?.(t); }
    function drawHistoryChart(){ return window.OverlayHistory?.drawHistoryChart?.(); }
    function setChartCurrency(cur){ return window.OverlayHistory?.setChartCurrency?.(cur); }
    function nextAllowedRefreshAt(){ return window.OverlayHistory?.nextAllowedRefreshAt?.(); }
    function updateHistoryRefreshButton(){ return window.OverlayHistory?.updateHistoryRefreshButton?.(); }
    // HTML wrapper previously called refreshHistoryIfAllowed without required render callbacks (causing TypeError in minified bundle).
    async function refreshHistoryIfAllowed(origin){ 
        try {
            const H = window.OverlayHistory;
            if (!H || typeof H.refreshHistoryIfAllowed !== 'function') return;
            return await H.refreshHistoryIfAllowed(
                origin,
                (detailCb)=>{ try { H.renderHistoryList(detailCb); } catch(e){ console.warn('[History HTML wrapper] list render failed', e);} },
                (idx)=>{ try { H.renderHistoryDetail(idx); } catch(e){ console.warn('[History HTML wrapper] detail render failed', e);} }
            );
        } catch(e){ console.warn('[History HTML wrapper] refreshHistoryIfAllowed error', e); }
    }
    function parseRateLimitHeaders(headers, status){ return window.OverlayHistory?.parseRateLimitHeaders?.(headers, status) ?? 0; }

        // Function to render content with current filters applied
        function renderFilteredContent(data) { try { return window.OverlayModifiers?.renderFilteredContent?.(data); } catch {} }

        // Minimal helpers for panel visibility and category detail
        function hideAllPanels(){
            const cp = document.getElementById('craftingPanel'); 
            if (cp) cp.style.display='none'; 
            document.body.classList.remove('crafting-mode');
            hideHistoryView(); // Always hide history when switching views
            // Explicitly hide merchant history header elements to prevent leakage
            const mhIds = ['historyHeader','historyHeaderLeft','historyHeaderMain','historyPinned','historyActiveFilters'];
            mhIds.forEach(function(id){ var el=document.getElementById(id); if(el) el.style.display='none'; });
        }
        function prepareCharacterPanel(title){
            const cp = document.getElementById('craftingPanel'); if (!cp) return;
            // Hide other views to avoid overlap
            const mod = document.getElementById('content'); if (mod) mod.style.display='none';
            hideHistoryView(); // Ensure history is hidden
            document.body.classList.add('crafting-mode');
            cp.style.display='block';
            setControlPanelVisible(false);
            // Update shared reference used by character subviews
            craftingPanelEl = cp;
            cp.innerHTML='';
            
        }
        function renderCategoryDetail(data){
            try { window.OverlayModifiers?.mechanicsPostProcess?.(data); } catch {}
            window.originalData = data; currentData = data;
            try { renderFilteredContent(data); } catch {}
        }
        

    // Populate category dropdown on load
        async function populateCategoryDropdown() {
            if (!window.electronAPI || !window.electronAPI.getAllCategories) return;
            try {
                const categories = await window.electronAPI.getAllCategories();
                const categorySelect = document.getElementById('categorySelect');
                const previous = categorySelect.value;
        // Ensure aggregated pseudo-categories are always known and rendered first
        const AGGREGATED_CATEGORIES = ['ALL','DESECRATED','ESSENCE','CORRUPTED','SOCKETABLE','SOCKETABLES'];
        const aggregatedSet = new Set(AGGREGATED_CATEGORIES.map(c => c.toUpperCase()));

                function classify(cat) {
                    const u = cat.toUpperCase();
                    if (aggregatedSet.has(u)) return 'aggregated';
                    if (u.startsWith('WAYSTONES_')) return 'waystones';
                    if (/(_RELIC)$/.test(u)) return 'relics';
                    if (u === 'LIFE_FLASKS' || u === 'MANA_FLASKS' || u === 'CHARMS') return 'flasks';
                    if (u === 'PRECURSOR_TABLET' || /_PRECURSOR_TABLET$/.test(u)) return 'tablets';
                    if (u === 'JEWELS' || /^RUBY$/.test(u) || /^EMERALD$/.test(u) || /^SAPPHIRE$/.test(u) || /^TIME-LOST_RUBY$/.test(u) || /^TIME-LOST_EMERALD$/.test(u) || /^TIME-LOST_SAPPHIRE$/.test(u)) return 'jewels';
                    if (u === 'STRONGBOX' || u === 'STRONGBOX_UNIQUES' || u === 'EXPEDITION_LOGBOOK') return 'mechanics';
                    return 'gear';
                }

                const buckets = { aggregated:[], gear:[], waystones:[], relics:[], flasks:[], tablets:[], jewels:[], mechanics:[] };
                const nonModifierCats = new Set([
                    'LIQUID_EMOTIONS','ANNOINTS','ESSENCES','OMENS','CATALYSTS','SOCKETABLES','GEMS','KEYSTONES','ASCENDANCY_PASSIVES','ATLAS_NODES','KEYWORDS','UNIQUES','BASES','CURRENCY'
                ]);
                // First, put all aggregated explicitly into the aggregated bucket (preserve our preferred order)
                for (const a of AGGREGATED_CATEGORIES) {
                    const hit = (categories||[]).find(c => String(c).toUpperCase() === a);
                    if (hit) buckets.aggregated.push(hit);
                }
                // Then, distribute the rest (excluding non-modifier and aggregated)
                for (const c of categories) {
                    const u = (c||'').toUpperCase();
                    if (aggregatedSet.has(u)) continue;
                    if (nonModifierCats.has(u)) continue;
                    const g = classify(c);
                    buckets[g].push(c);
                }

                // buildOptions builds grouped & filtered list
                function buildOptions(filterText='') {
                    categorySelect.innerHTML = `<option value="">${filterText? 'Filter: '+filterText : 'Select category...'}</option>`;
                    const f = filterText.toLowerCase();
                    function addGroup(label, list, transform=(c)=>c.replace(/_/g,' '), upper=false) {
                        const subset = f ? list.filter(c => transform(c).toLowerCase().includes(f)) : list.slice();
                        if (!subset.length) return;
                        const groupLabel = document.createElement('option');
                        groupLabel.textContent = label;
                        groupLabel.disabled = true;
                        categorySelect.appendChild(groupLabel);
                        subset.sort().forEach(c => {
                            const opt = document.createElement('option');
                            opt.value = c;
                            opt.textContent = upper ? c.toUpperCase() : transform(c);
                            categorySelect.appendChild(opt);
                        });
                        const div = document.createElement('option');
                        div.textContent = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
                        div.disabled = true;
                        categorySelect.appendChild(div);
                    }
                    // Ensure aggregated remains first group
                    addGroup('â€” Aggregated â€”', buckets.aggregated, c=>c.toUpperCase(), true);
                    addGroup('â€” Gear â€”', buckets.gear);
                    addGroup('â€” Waystones â€”', buckets.waystones);
                    addGroup('â€” Relics â€”', buckets.relics, c=>c.replace(/_/g,' '));
                    addGroup('â€” Flasks & Charms â€”', buckets.flasks, c=>c.replace(/_/g,' '));
                    addGroup('â€” Tablets â€”', buckets.tablets, c=>c.replace(/_/g,' '));
                }
                // initial build with no filter
                buildOptions('');
            } catch {}
        }
        // Wire initial controls on DOM ready
        document.addEventListener('DOMContentLoaded', async () => {
            // Feature-aware tab visibility (hide disabled features)
            try {
                const enabledFeatures = await window.electronAPI?.getEnabledFeatures?.();
                console.log('[FeatureFilter] Enabled features:', enabledFeatures);
                
                if (enabledFeatures) {
                    let modifiersEnabled = !!enabledFeatures.modifiers;
                    let historyEnabled = !!enabledFeatures.merchant;
                    let craftingViewEnabled = false;

                    // Hide Modifier tab if disabled
                    if (!enabledFeatures.modifiers) {
                        console.log('[FeatureFilter] Hiding Modifier tab (modifiers disabled)');
                        const modTab = document.getElementById('tabModifier');
                        if (modTab) {
                            modTab.remove();
                            console.log('[FeatureFilter] Modifier tab removed');
                        }
                        modifiersEnabled = false;
                    } else {
                        modifiersEnabled = true;
                    }
                    
                    // Hide Merchant History tab if disabled
                    if (!enabledFeatures.merchant) {
                        console.log('[FeatureFilter] Hiding Merchant History tab (merchant disabled)');
                        const histTab = document.getElementById('tabHistory');
                        if (histTab) histTab.remove();
                        historyEnabled = false;
                    } else {
                        historyEnabled = true;
                    }
                    
                    // Filter Crafting submenu items
                    if (enabledFeatures.crafting && !enabledFeatures.crafting.enabled) {
                        const craftingTab = document.getElementById('craftingTab');
                        if (craftingTab) craftingTab.remove();
                    } else if (enabledFeatures.crafting?.enabled) {
                        const craftMenu = document.getElementById('craftingMenu');
                        const subs = enabledFeatures.crafting.subcategories || {};
                        let anySubEnabled = false;
                        
                        if (craftMenu) {
                            const items = craftMenu.querySelectorAll('.crafting-menu-item');
                            items.forEach(item => {
                                const action = item.getAttribute('data-action');
                                let shouldShow = false;
                                
                                if (action === 'liquid-emotions' && subs.liquidEmotions) shouldShow = true;
                                if (action === 'annoints' && subs.annoints) shouldShow = true;
                                if (action === 'essences' && subs.essences) shouldShow = true;
                                if (action === 'omens' && subs.omens) shouldShow = true;
                                if (action === 'currency' && subs.currency) shouldShow = true;
                                if (action === 'catalysts' && subs.catalysts) shouldShow = true;
                                if (action === 'socketables' && subs.socketables) shouldShow = true;
                                
                                if (shouldShow) {
                                    anySubEnabled = true;
                                    item.style.display = '';
                                } else {
                                    item.style.display = 'none';
                                }
                            });
                        }
                        
                        // Hide entire Crafting tab if no subcategories enabled
                        if (!anySubEnabled) {
                            const craftingTab = document.getElementById('craftingTab');
                            if (craftingTab) craftingTab.remove();
                        }
                    }
                    if (document.getElementById('craftingTab')) craftingViewEnabled = true;
                    
                    // Filter Character submenu items
                    if (enabledFeatures.character && !enabledFeatures.character.enabled) {
                        const charTab = document.getElementById('characterTab');
                        if (charTab) charTab.remove();
                    } else if (enabledFeatures.character?.enabled) {
                        const charMenu = document.getElementById('characterMenu');
                        const subs = enabledFeatures.character.subcategories || {};
                        let anySubEnabled = false;
                        
                        if (charMenu) {
                            const items = charMenu.querySelectorAll('.character-menu-item');
                            items.forEach(item => {
                                const action = item.getAttribute('data-action');
                                let shouldShow = false;
                                
                                if (action === 'quest-passives' && subs.questPassives) shouldShow = true;
                                if (action === 'keystones' && subs.keystones) shouldShow = true;
                                if (action === 'asc-passives' && subs.ascendancyPassives) shouldShow = true;
                                if (action === 'atlas-nodes' && subs.atlasNodes) shouldShow = true;
                                if (action === 'gems' && subs.gems) shouldShow = true;
                                if (action === 'glossar' && subs.glossar) shouldShow = true;
                                
                                if (shouldShow) {
                                    anySubEnabled = true;
                                    item.style.display = '';
                                } else {
                                    item.style.display = 'none';
                                }
                            });
                        }
                        
                        // Hide entire Character tab if no subcategories enabled
                        if (!anySubEnabled) {
                            const charTab = document.getElementById('characterTab');
                            if (charTab) charTab.remove();
                        }
                    }
                    if (document.getElementById('characterTab')) craftingViewEnabled = true;
                    
                    // Filter Items submenu items
                    if (enabledFeatures.items && !enabledFeatures.items.enabled) {
                        const itemsTab = document.getElementById('itemsTab');
                        if (itemsTab) itemsTab.remove();
                    } else if (enabledFeatures.items?.enabled) {
                        const itemsMenu = document.getElementById('itemsMenu');
                        const subs = enabledFeatures.items.subcategories || {};
                        let anySubEnabled = false;
                        
                        if (itemsMenu) {
                            const items = itemsMenu.querySelectorAll('.items-menu-item');
                            items.forEach(item => {
                                const action = item.getAttribute('data-action');
                                let shouldShow = false;
                                
                                if (action === 'uniques' && subs.uniques) shouldShow = true;
                                if (action === 'bases' && subs.bases) shouldShow = true;
                                
                                if (shouldShow) {
                                    anySubEnabled = true;
                                    item.style.display = '';
                                } else {
                                    item.style.display = 'none';
                                }
                            });
                        }
                        
                        // Hide entire Items tab if no subcategories enabled
                        if (!anySubEnabled) {
                            const itemsTab = document.getElementById('itemsTab');
                            if (itemsTab) itemsTab.remove();
                        }
                    }
                    if (document.getElementById('itemsTab')) craftingViewEnabled = true;
                    
                    // Tools menu
                    if (enabledFeatures.tools && !enabledFeatures.tools.enabled) {
                        const toolsTab = document.getElementById('toolsTab');
                        if (toolsTab) toolsTab.remove();
                    } else if (enabledFeatures.tools?.enabled) {
                        const toolsMenu = document.getElementById('toolsMenu');
                        const subs = enabledFeatures.tools.subcategories || {};
                        let anySubEnabled = false;
                        
                        if (toolsMenu) {
                            const items = toolsMenu.querySelectorAll('.tools-menu-item');
                            items.forEach(item => {
                                const action = item.getAttribute('data-action');
                                let shouldShow = false;
                                
                                if (action === 'regex' && subs.regex) shouldShow = true;
                                
                                if (shouldShow) {
                                    anySubEnabled = true;
                                    item.style.display = '';
                                } else {
                                    item.style.display = 'none';
                                }
                            });
                        }
                        
                        // Hide entire Tools tab if no subcategories enabled
                        if (!anySubEnabled) {
                            const toolsTab = document.getElementById('toolsTab');
                            if (toolsTab) toolsTab.remove();
                        }
                    }
                    if (document.getElementById('toolsTab')) craftingViewEnabled = true;

                    setFeatureAvailability({
                        modifiers: modifiersEnabled,
                        crafting: craftingViewEnabled,
                        history: historyEnabled
                    });
                    
                    // Set first visible tab as active and default view
                    const tabOrder = ['tabModifier', 'craftingTab', 'characterTab', 'itemsTab', 'toolsTab', 'tabHistory'];
                    let firstVisibleTab = null;
                    for (const tabId of tabOrder) {
                        const tab = document.getElementById(tabId);
                        if (tab && window.getComputedStyle(tab).display !== 'none') {
                            firstVisibleTab = tabId;
                            break;
                        }
                    }
                    if (firstVisibleTab) {
                        const targetView = firstVisibleTab === 'tabModifier' ? 'modifiers'
                                          : firstVisibleTab === 'tabHistory' ? 'history'
                                          : 'crafting';
                        try { setView(targetView); } catch {}
                        try { setActiveTab(firstVisibleTab); } catch {}
                        if (firstVisibleTab === 'tabHistory') {
                            try { setHeader('Merchant History'); } catch {}
                        } else if (firstVisibleTab === 'tabModifier') {
                            try { setHeader('Modifier'); } catch {}
                        } else {
                            try { setHeader('Crafting'); } catch {}
                        }
                    }
                }
            } catch (err) {
                console.error('[Tab visibility] Error:', err);
            }
            
            try { populateCategoryDropdown(); } catch {}
            // Re-populate once modifiers fully loaded (ensures full category list when opening without item)
            try { window.electronAPI?.onModifiersLoaded?.((_cats)=> { try { populateCategoryDropdown(); } catch {} }); } catch {}
            if (!headerTitleEl || !headerTitleEl.textContent) {
                const fallbackView = pickFirstAvailableView('modifiers');
                if (fallbackView === 'history') {
                    setHeader('Merchant History');
                } else if (fallbackView === 'crafting') {
                    setHeader('Crafting');
                } else {
                    setHeader('Modifier');
                }
            }
            // Initial UI state (tab already set above based on enabled features)
            try { closeAllMenus(); } catch {}
            const select = document.getElementById('categorySelect');
            if (select) select.addEventListener('change', switchCategory);
            // Header actions
            if (closeBtn) closeBtn.addEventListener('click', ()=>{ try { window.electronAPI?.hideOverlay?.(); } catch {} });
            function updatePinUI(pinned){ if (!pinBtn) return; pinBtn.classList.toggle('active', !!pinned); pinBtn.textContent = pinned ? 'Pinned' : 'Pin'; }
            if (pinBtn) pinBtn.addEventListener('click', ()=>{ try { const isPinned = pinBtn.classList.contains('active'); window.electronAPI?.setPinned?.(!isPinned); updatePinUI(!isPinned); } catch {} });
            try { window.electronAPI?.onPinnedChanged?.((p)=> updatePinUI(p)); } catch {}
            
            // Notify main process that overlay is ready (this will trigger pinned state sync)
            try { window.electronAPI?.overlayReady?.(); } catch {}
            
            // Font size management - robust scaling for all inline px fonts
            (async function() {
                try {
                    if (!window.electronAPI) return;

                    const STATE = {
                        scale: 1,
                        scaledAttr: 'data-font-scaled'
                    };

                    function isTextual(el){
                        const tag = el.tagName;
                        if (!tag) return false;
                        return !(
                            tag === 'IMG' || tag === 'SVG' || tag === 'CANVAS' ||
                            tag === 'VIDEO' || tag === 'AUDIO' ||
                            tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT'
                        );
                    }

                    function hasScaledAncestor(el){
                        try {
                            let p = el.parentElement;
                            while (p && p !== document.body){
                                if (p.getAttribute && p.getAttribute(STATE.attr)) return true;
                                p = p.parentElement;
                            }
                        } catch {}
                        return false;
                    }

                    // Find nearest ancestor that we previously marked with a stored base font
                    function nearestScaledAncestor(el){
                        try {
                            let p = el.parentElement;
                            while (p && p !== document.body){
                                if (p.getAttribute && p.getAttribute(STATE.attr)) return p;
                                p = p.parentElement;
                            }
                        } catch {}
                        return null;
                    }

                    function scaleElement(el, scale){
                        if (!isTextual(el)) return;
                        try {
                            let base = el.getAttribute(STATE.attr);
                            if (!base){
                                const cs = getComputedStyle(el);
                                let px = parseFloat(cs.fontSize) || 12;
                                // If an ancestor was already scaled and this element doesn't have its own inline font-size
                                // then its computed font-size already includes the ancestor scale. Normalize it out so we don't square the scale.
                                const hasInline = !!(el && el.style && el.style.fontSize);
                                if (!hasInline) {
                                    const anc = nearestScaledAncestor(el);
                                    if (anc) {
                                        const ancPx = parseFloat(getComputedStyle(anc).fontSize) || 0;
                                        const elPxNow = px;
                                        // Only normalize if element appears to inherit ancestor size (computed sizes are effectively equal)
                                        if (Math.abs(elPxNow - ancPx) < 0.5) {
                                            px = elPxNow / (STATE.scale || 1);
                                        }
                                    }
                                }
                                // Detect headline-like text (names/titles): heavy weight and larger base size
                                const fwRaw = (cs.fontWeight || '').toString();
                                const fw = /bold/i.test(fwRaw) ? 700 : (parseInt(fwRaw, 10) || 400);
                                const isHeadline = (fw >= 600 && px >= 13) || px >= 14;
                                el.setAttribute(STATE.attr, String(px));
                                if (isHeadline) el.setAttribute('data-font-headline', '1');
                                base = String(px);
                            }
                            const basePx = parseFloat(base) || 12;
                            // Apply sublinear scaling to headline-like text to avoid oversized names
                            const isHeadline = el.getAttribute('data-font-headline') === '1';
                            const effScale = isHeadline ? (1 + (scale - 1) * 0.6) : scale;
                            let newPx = Math.round(basePx * effScale);
                            if (!isFinite(newPx) || newPx < 8) newPx = 8;
                            // Optional soft cap to avoid runaway titles
                            if (isHeadline && newPx > 22) newPx = 22;
                            el.style.fontSize = newPx + 'px';
                            // Mark as scaled so we can safely reset only our own inline sizes later
                            el.setAttribute(STATE.scaledAttr, '1');
                        } catch {}
                    }

                    function applyScale(root, scale){
                        if (!root) root = document.body;
                        // Do not scale the root container to avoid inheritance compounding
                        // All descendants
                        const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
                        let node;
                        while ((node = walker.nextNode())){
                            scaleElement(node, scale);
                        }
                    }

                    // One-time purge of previously inlined font sizes to establish a clean baseline
                    function purgeFontState(){
                        try {
                            const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT);
                            let node;
                            while ((node = walker.nextNode())){
                                if (node.nodeType === 1){
                                    // Only reset sizes that we previously applied; preserve original inline font-sizes
                                    if (node.getAttribute && node.getAttribute(STATE.scaledAttr) === '1'){
                                        if (node.style && node.style.fontSize) node.style.fontSize = '';
                                    }
                                    if (node.removeAttribute){
                                        node.removeAttribute(STATE.attr);
                                        node.removeAttribute(STATE.scaledAttr);
                                    }
                                }
                            }
                        } catch {}
                    }

                    // Observe dynamic content and scale newcomers using stored base
                    let observer;
                    function ensureObserver(){
                        try {
                            if (observer) return;
                            observer = new MutationObserver((mutations)=>{
                                for (const m of mutations){
                                    m.addedNodes && m.addedNodes.forEach(n=>{
                                        if (n.nodeType === 1){
                                            applyScale(n, STATE.scale);
                                        }
                                    });
                                }
                            });
                            observer.observe(document.body, { childList: true, subtree: true });
                        } catch {}
                    }

                    function setFontScale(percent){
                        const scale = Math.max(0.8, Math.min(1.5, (Number(percent)||100) / 100));
                        STATE.scale = scale;
                        applyScale(document.body, scale);
                        ensureObserver();
                        console.log('[FontSize] Applied scale:', percent + '% =>', scale);
                    }

                    // Initial load: purge inline sizes once, then set scale
                    purgeFontState();
                    const size = await window.electronAPI.getFontSize();
                    setFontScale(size);

                    // Live changes from Settings window
                    window.electronAPI.onFontSizeChanged((size) => setFontScale(size));
                } catch (e) {
                    console.warn('[FontSize] Error:', e);
                }
            })();
            
            const search = document.getElementById('search-input');
            if (search) search.addEventListener('input', () => { if (window.originalData) try { renderFilteredContent(window.originalData); } catch {} });
            // iLvl filters (debounced 500ms)
            const ilvlMinEl = document.getElementById('ilvl-min');
            const ilvlMaxEl = document.getElementById('ilvl-max');
            let ilvlDebounce = null;
            function queueIlvlFilter(){
                if (ilvlDebounce) clearTimeout(ilvlDebounce);
                ilvlDebounce = setTimeout(()=>{ if(window.originalData) try { renderFilteredContent(window.originalData); } catch {} }, 500);
            }
            if (ilvlMinEl) ilvlMinEl.addEventListener('input', queueIlvlFilter);
            if (ilvlMaxEl) ilvlMaxEl.addEventListener('input', queueIlvlFilter);
            const clear = document.getElementById('clearFilters');
            if (clear) clear.addEventListener('click', () => {
                const s = document.getElementById('search-input'); if (s) s.value = '';
                try { window.OverlayModifiers?.clearAllFilters?.(); } catch {}
                if (window.originalData) try { renderFilteredContent(window.originalData); } catch {}
            });
            
            // Initialize domain toggle buttons (radio button behavior)
            const domainButtons = ['toggleAll', 'toggleBase', 'toggleDesecrated', 'toggleEssence', 'toggleCorrupted'];
            domainButtons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.addEventListener('click', () => {
                        // Remove active class from all domain buttons
                        domainButtons.forEach(otherId => {
                            const otherBtn = document.getElementById(otherId);
                            if (otherBtn) otherBtn.classList.remove('active');
                        });
                        // Add active class to clicked button
                        btn.classList.add('active');
                        // Re-render with new filter
                        if (window.originalData) try { renderFilteredContent(window.originalData); } catch {}
                    });
                }
            });
            // Default view: use single source of truth
            setView('modifiers');
            // Wire clipboard item detection to auto-open correct category
            if (window.electronAPI && typeof window.electronAPI.onItemData === 'function') {
                window.electronAPI.onItemData(async (data) => {
                    try {
                        if (!data || !data.item) return;
                        // Always start from a clean state
                        closeAllMenus();

                        const item = data.item || {};
                        const rarity = (item.rarity || '').toLowerCase();
                        const name = item.name || '';
                        const baseType = item.baseType || '';
                        const category = (item.category || '').toString();
                        const blob = `${name} ${baseType} ${category}`.toLowerCase();
                        const frameType = String(item && item.frameType || '');
                        const icon = String(item && item.icon || '');

                        console.log('Clipboard item detected:', {
                            rarity: rarity,
                            name: name,
                            baseType: baseType,
                            category: category,
                            frameType: frameType,
                            icon: icon,
                            isUnique: data.isUnique,
                            itemClass: item.itemClass || 'unknown',
                            fullBlob: blob
                        });

                        // Small helper: prepare crafting view and run a show() with a couple retries
                        const prepareCrafting = (headerTitle) => {
                            setView('crafting');
                            setHeader(headerTitle || '');
                        };
                        const retryShow = (readyFn, runFn, attempts = 3) => {
                            if (readyFn()) { try { runFn(); } catch {} return; }
                            if (attempts <= 0) return;
                            setTimeout(() => retryShow(readyFn, runFn, attempts - 1), 120);
                        };

                        // Route checks - order matters!
                        // Hard rule: Handle unique items first - use simple text detection like essences
                        const isUnique = /unique/i.test(name) || /unique/i.test(baseType) || /unique/i.test(blob) || 
                                        data.isUnique || /unique/i.test(rarity) || frameType === '3' || String(frameType) === '3' ||
                                        /\bUniques\//i.test(icon);
                        
                        if (isUnique) {
                            console.log('Unique item detected via simple pattern matching like essences:', {
                                name: name,
                                baseType: baseType,
                                blob: blob,
                                category: category,
                                rarity: rarity,
                                frameType: frameType,
                                icon: icon,
                                isUniqueFlag: data.isUnique
                            });
                            prepareCrafting('Uniques');
                            retryShow(
                                () => !!(window.OverlayUniques && typeof window.OverlayUniques.show === 'function'),
                                async () => {
                                    try { await showUniques(); } catch {}
                                    // Removed auto highlight to prevent unintended scroll movement
                                }
                            );
                            return;
                        }

                        const isEssence = /essence/i.test(name) || /essence/i.test(baseType) || /essences?/i.test(blob);
                        const isOmen = /omen/i.test(blob);
                        const isCatalyst = /catalyst/i.test(blob);
                        // Socketables exclude Waystones now; handle Waystones separately so they stay in Modifiers
                        const isSocketable = /socketable|socketables/i.test(blob);
                        const isWaystone = /waystone|waystones/i.test(blob) || /^Waystones?_?/i.test(category || '');
                        // Fix: Liquid Emotions detection based on name, not category
                        const isEmotion = /liquid\s*(emotion|envy|hatred|fear|anguish|despair|suffering|greed|contempt|ire)/i.test(name) || /liquid\s*emotion/i.test(baseType);
                        // Fix: Gems should route to Character > Gems - use itemClass instead of text matching to avoid false positives with "spirit" in rare item names
                        const itemClass = (item.itemClass || '').toLowerCase();
                        const isGem = itemClass.includes('skill gem') || itemClass.includes('spirit gem') || itemClass.includes('uncut spirit gem') || itemClass.includes('support gem');

                        // (unique via frame/icon was handled above)

                        if (isEssence) {
                            prepareCrafting('Essences');
                            retryShow(
                                () => !!(window.OverlayEssences && typeof window.OverlayEssences.show === 'function'),
                                async () => { try { await showEssences(); } catch {} }
                            );
                            return;
                        }

                        if (isOmen) {
                            prepareCrafting('Omens');
                            retryShow(
                                () => !!(window.OverlayOmens && typeof window.OverlayOmens.show === 'function'),
                                async () => { try { await showOmens(); } catch {} }
                            );
                            return;
                        }

                        if (isCatalyst) {
                            prepareCrafting('Catalysts');
                            retryShow(
                                () => !!(window.OverlayCatalysts && typeof window.OverlayCatalysts.show === 'function'),
                                async () => { try { await showCatalysts(); } catch {} }
                            );
                            return;
                        }

                        if (isSocketable) {
                            prepareCrafting('Socketables');
                            retryShow(
                                () => !!(window.OverlaySocketables && typeof window.OverlaySocketables.show === 'function'),
                                async () => { try { await showSocketables(); } catch {} }
                            );
                            return;
                        }

                        if (isWaystone) {
                            // Keep Waystones in Modifiers tab; derive Low/Mid/Top category if provided by backend
                            setView('modifiers');
                            setHeader('Waystones');
                            // Decide variant: prefer provided category, else simple heuristic
                            let wsCat = (category || '').startsWith('Waystones_') ? category : '';
                            if (!wsCat) {
                                // Heuristic by Area Level or Tier inside blob if needed (client side fallback)
                                const tierMatch = blob.match(/Waystone\s*Tier\s*(\d+)/i) || name.match(/Tier\s*(\d+)/i);
                                if (tierMatch) {
                                    const t = parseInt(tierMatch[1], 10);
                                    if (t >=1 && t <=5) wsCat = 'Waystones_Low'; else if (t<=10) wsCat = 'Waystones_Mid'; else wsCat = 'Waystones_Top';
                                }
                            }
                            if (!wsCat) wsCat = 'Waystones_Low';
                            // Update item.category so dropdown gets set correctly below
                            item.category = wsCat;
                            // Don't return - let the normal category handling code process it
                        }

                        if (isEmotion) {
                            prepareCrafting('Liquid Emotions');
                            retryShow(
                                () => !!(window.OverlayLiquid && typeof window.OverlayLiquid.show === 'function'),
                                async () => { try { await showLiquidEmotions(); } catch {} }
                            );
                            return;
                        }

                        if (isGem) {
                            // Route to Character > Gems directly (no crafting mode)
                            setView('character');
                            retryShow(
                                () => !!(window.OverlayGems && typeof window.OverlayGems.show === 'function'),
                                async () => { 
                                    try { 
                                        await showGems(); 
                                        setActiveTab('characterTab');
                                    } catch {} 
                                }
                            );
                            return;
                        }

                        // Default: Modifiers view
                        const tabModEl = document.getElementById('tabModifier'); const tabHistEl = document.getElementById('tabHistory');
                        if (tabModEl && tabHistEl) {
                            tabModEl.classList.add('active');
                            tabModEl.setAttribute('style','background: var(--accent-blue); color: #fff; border: 1px solid var(--accent-blue); border-radius: 4px; padding: 3px 8px; font-size: 12px;');
                            tabHistEl.classList.remove('active');
                            tabHistEl.setAttribute('style','background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px;');
                        }
                        setView('modifiers');
                        await populateCategoryDropdown();
                        const categorySelect = document.getElementById('categorySelect');
                        if (categorySelect && item.category) {
                            const slug = String(item.category);
                            console.log('Looking for category option:', slug);
                            const opt = Array.from(categorySelect.options||[]).find(o=>o.value===slug);
                            console.log('Found option:', opt);
                            if (opt) { 
                                // Set dropdown value WITHOUT triggering change event (data already has modifiers)
                                categorySelect.value = slug;
                                console.log('Set category dropdown to:', slug, '(no reload, using provided modifiers)');
                            } else {
                                console.log('Category option not found in dropdown for:', slug);
                            }
                        }
                        // Render directly with provided modifiers (no need to reload)
                        window.originalData = data;
                        try { window.OverlayModifiers?.mechanicsPostProcess?.(data); } catch {}
                        renderFilteredContent(data);
                        setHeader('Modifier');
                    } catch (e) { console.warn('onItemData handling failed', e); }
                });
            }
        });
            if (tabMod) {
                tabMod.addEventListener('click', () => {
                    setActiveTab('tabModifier');
                    closeAllMenus();
                    setView('modifiers'); // Use single source of truth
                    document.getElementById('modifierHeaderInfo')?.setAttribute('style','');
                    document.getElementById('whittlingInfo')?.setAttribute('style','margin-right: 8px; display:none; -webkit-app-region: no-drag;');
                    setControlPanelVisible(true);
                    document.body.classList.remove('crafting-mode');
                    setHeader('Modifier');
                    
                });
            }

            // Crafting dropdown toggle
            if (craftingTab) {
                craftingTab.addEventListener('click', (e) => {
                    e.stopPropagation();
                    setActiveTab('craftingTab');
                    const tabHistEl = document.getElementById('tabHistory');
                    if (tabHistEl) {
                        tabHistEl.classList.remove('active');
                        tabHistEl.setAttribute('style','background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px;');
                    }
                    const vis = craftingMenu.style.display === 'block';
                    closeAllMenus();
                    craftingMenu.style.display = vis ? 'none' : 'block';
                });
                window.addEventListener('click', () => { craftingMenu.style.display = 'none'; });
                craftingMenu.addEventListener('click', (e) => { e.stopPropagation(); });
                craftingMenu.querySelectorAll('.crafting-menu-item').forEach(item => {
                    item.addEventListener('click', async (e) => {
                        const action = item.getAttribute('data-action');
                        craftingMenu.style.display = 'none';
                        // Switch to crafting view using the single source of truth
                        setActiveTab('craftingTab');
                        closeAllMenus();
                        setView('crafting');
                        if (action === 'liquid-emotions') {
                            await showLiquidEmotions();
                            setHeader('Liquid Emotions');
                            
                        } else if (action === 'annoints') {
                            await showAnnoints();
                            setHeader('Annoints');
                            
                        } else if (action === 'essences') {
                            await showEssences();
                            setHeader('Essences');
                            
                        } else if (action === 'omens') {
                            await showOmens();
                            setHeader('Omens');
                        } else if (action === 'currency') {
                            await showCurrency();
                            setHeader('Currency');
                            
                        } else if (action === 'catalysts') {
                            await showCatalysts();
                            setHeader('Catalysts');
                            
                        } else if (action === 'socketables') {
                            await showSocketables();
                            setHeader('Socketables');
                            
                        }
                    });
                });
            }

            if (loginBtn) {
                loginBtn.addEventListener('click', async () => {
                    // Check if logged in - if yes, open trade history page; if no, show login window
                    const session = await window.electronAPI.poeGetSession();
                    if (session?.loggedIn) {
                        await window.electronAPI.poeOpenHistoryWindow();
                    } else {
                        const res = await window.electronAPI.poeLogin();
                        if (res?.loggedIn) {
                            await updateSessionUI();
                            // Do not auto-refresh on login; user controls refresh explicitly
                        }
                    }
                });
            }
            // Refresh button logic now handled by modular history system (refreshButton.ts)
            // Legacy confirm() popup removed to avoid duplicate dialogs and native alert.
            // attachRefreshButtonLogic() (called in history/module.ts) wires the styled confirmation dialog.
            // We leave this block intentionally empty to prevent double-binding.
            // (If needed in future, ensure not to reintroduce native confirm here.)
            
            // History popout button
            const popoutBtn = document.getElementById('historyPopoutBtn');
            if (popoutBtn) {
                popoutBtn.addEventListener('click', async () => {
                    try {
                        if (typeof window.OverlayHistory?.onOpenPopout === 'function') {
                            await window.OverlayHistory.onOpenPopout();
                        }
                    } catch (e) {
                        console.error('Failed to open history popout:', e);
                    }
                });
            }
            
            // Chart expand button - expands chart to take full right panel space
            const chartExpandBtn = document.getElementById('chartExpandBtn');
            const historyRight = document.getElementById('historyRight');
            if (chartExpandBtn && historyRight) {
                chartExpandBtn.addEventListener('click', () => {
                    const expanded = historyRight.classList.toggle('history-chart-expanded');
                    chartExpandBtn.textContent = expanded ? 'â–¼' : 'â–²';
                    chartExpandBtn.title = expanded ? 'Show item details panel' : 'Expand chart to take full space';

                    const refresh = () => {
                        try { if (typeof drawHistoryChart === 'function') drawHistoryChart(); } catch {}
                    };

                    requestAnimationFrame(() => {
                        refresh();
                        setTimeout(refresh, 120);
                    });
                });
            }
            
            if (typeof updateHistoryRefreshButton === 'function') { try { updateHistoryRefreshButton(); } catch {} }

            // History tab toggle: show history container and hide modifiers/crafting
            if (tabHist) {
                tabHist.addEventListener('click', () => {
                    setActiveTab('tabHistory');
                    closeAllMenus();
                    // Use strong view gate
                    setView('history');
                    // ensure history UI readiness
                    try { updateSessionUI(); } catch {}
                    try { if (typeof refreshHistoryIfAllowed === 'function') refreshHistoryIfAllowed('nav'); } catch {}
                    // proactively render from store before/while fetching
                    try { if (typeof renderHistoryTotals === 'function') renderHistoryTotals(); } catch {}
                    try { if (typeof renderHistoryActiveFilters === 'function') renderHistoryActiveFilters(); } catch {}
                    try { if (typeof renderHistoryList === 'function') renderHistoryList(); } catch {}
                    try { if (typeof renderHistoryDetail === 'function') renderHistoryDetail(0); } catch {}
                    // proactively compute and draw chart from last known data if available
                    try { if (typeof recomputeChartSeriesFromStore === 'function') recomputeChartSeriesFromStore(); } catch {}
                    // Draw after container becomes visible â€“ schedule multiple attempts
                    try {
                        if (typeof drawHistoryChart === 'function') {
                            drawHistoryChart(); // immediate
                            requestAnimationFrame(()=>{ try { drawHistoryChart(); } catch {} });
                            setTimeout(()=>{ try { drawHistoryChart(); } catch {} }, 50);
                            setTimeout(()=>{ try { drawHistoryChart(); } catch {} }, 150);
                            setTimeout(()=>{ try { drawHistoryChart(); } catch {} }, 300);
                        }
                    } catch {}
                    setHeader('Merchant History');
                    
                });
            }

            // Mask toggle feature removed (account name no longer displayed)

            // Filters UI wiring
            const minEl = document.getElementById('histMinValue');
            const curEl = document.getElementById('histCurrency');
            const catEl = document.getElementById('histCategory');
            const sortEl = document.getElementById('histSort');
            const rarEl = document.getElementById('histRarity');
            const timeEl = document.getElementById('histTimeframe');
            const searchEl = document.getElementById('histSearch');
            
            // Deferred filter binding: retry until OverlayHistory is actually attached & ready.
            (function bindHistoryFilters(attempt=0){
                const H = window.OverlayHistory;
                const ready = !!(H && H.historyState && typeof H.applyAndRender === 'function');
                if (!ready){
                    if (attempt === 0) console.log('[Filter Setup] OverlayHistory not ready yet â€“ deferring');
                    if (attempt < 50) return setTimeout(()=>bindHistoryFilters(attempt+1), 100); // up to 5s
                    console.warn('[Filter Setup] Gave up waiting for OverlayHistory after 5s');
                    return;
                }
                console.log('[Filter Setup] Binding filters on attempt', attempt, 'state entries:', H.historyState.store?.entries?.length||0);
                const histState = H.historyState;
                const applyAndRenderFn = H.applyAndRender;
                const wire = (el, ev, fn)=>{ if(el){ el.addEventListener(ev, fn); el.setAttribute('data-filter-wired','1'); } };
                wire(minEl,'input', ()=>{ histState.filters.min = Number(minEl.value||0); applyAndRenderFn(); });
                wire(curEl,'change', ()=>{ histState.filters.cur = String(curEl.value||''); applyAndRenderFn(); });
                wire(catEl,'change', ()=>{ histState.filters.category = String(catEl.value||''); applyAndRenderFn(); });
                wire(sortEl,'change', ()=>{ histState.sort = String(sortEl.value||'newest'); applyAndRenderFn(); });
                wire(rarEl,'change', ()=>{ histState.filters.rarity = String(rarEl.value||''); applyAndRenderFn(); });
                wire(timeEl,'change', ()=>{ histState.filters.timeframe = String(timeEl.value||'all'); applyAndRenderFn(); });
                wire(searchEl,'input', ()=>{ histState.filters.search = String(searchEl.value||'').trim().toLowerCase(); applyAndRenderFn(); });
                console.log('[Filter Setup] Filters wired');
            })();
        

        // ===== Crafting: Liquid Emotions (delegation only) =====
        let craftingPanelEl = null;
        async function showLiquidEmotions() {
            if (window.OverlayLiquid && window.OverlayLiquid.show) { try { return await window.OverlayLiquid.show(); } catch {} }
        }

        function hideCraftingPanel() {
            const el = document.getElementById('craftingPanel');
            if (el) el.style.display = 'none';
        }

        function hideAnnointsPanel() {
            if (window.OverlayAnnoints && window.OverlayAnnoints.hide) { try { return window.OverlayAnnoints.hide(); } catch {} }
            const el = document.getElementById('annointsPanel');
            if (el) el.style.display = 'none';
        }

        function highlightLiquidEmotion(name) {
            if (window.OverlayLiquid && window.OverlayLiquid.highlight) { try { return window.OverlayLiquid.highlight(name); } catch {} }
        }

        async function reloadLiquidEmotions() {
            if (window.OverlayLiquid && window.OverlayLiquid.reload) { try { return await window.OverlayLiquid.reload(); } catch {} }
        }

        // History functions are delegated above; fallbacks removed

        // History implementation moved to module

        // History fallback moved to module

        // ===== Simple totals chart (canvas, no external deps) =====
    // Redraw on resize using module's chart
        window.addEventListener('resize', ()=> { try { drawHistoryChart(); } catch {} });
    // Draw again after a brief delay to handle first-layout canvas sizes
    document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(()=>{ try { drawHistoryChart(); } catch {} }, 50); });
        // Observe visibility/size changes on the historyRight container
        document.addEventListener('DOMContentLoaded', ()=>{
            const right = document.getElementById('historyRight');
            if (!right || typeof MutationObserver === 'undefined') return;
            const obs = new MutationObserver(()=>{ try { drawHistoryChart(); } catch {} });
            obs.observe(right, { attributes:true, attributeFilter:['style','class'] });
        });
        // Also observe actual size changes of the chart wrapper if supported
        document.addEventListener('DOMContentLoaded', ()=>{
            try {
                const wrap = document.getElementById('historyChartWrap');
                if (wrap && typeof ResizeObserver !== 'undefined') {
                    const ro = new ResizeObserver(() => { try { drawHistoryChart(); } catch {} });
                    ro.observe(wrap);
                }
            } catch {}
        });
        // Legend click handlers: delegate to module
        document.addEventListener('DOMContentLoaded', ()=>{
            const els = [
                document.getElementById('chartCur-divine'),
                document.getElementById('chartCur-exalted'),
                document.getElementById('chartCur-annul'),
                document.getElementById('chartCur-chaos'),
                document.getElementById('chartCur-regal')
            ].filter(Boolean);
            els.forEach(el=>{
                el.addEventListener('click', ()=>{
                    const cur = el.getAttribute('data-cur')||'divine';
                    try { setChartCurrency(cur); } catch {}
                    els.forEach(e=> e.classList.toggle('active', e===el));
                    drawHistoryChart();
                });
            });

            // Chart collapse/expand handler
            const collapseBtn = document.getElementById('chartCollapseBtn');
            const chartWrap = document.getElementById('historyChartWrap');
            const chartCanvas = document.getElementById('historyChart');
            let chartCollapsed = localStorage.getItem('historyChartCollapsed') === 'true';

            // Apply initial state
            if (chartCollapsed && collapseBtn && chartWrap && chartCanvas) {
                chartWrap.style.flex = '0 0 auto';
                chartWrap.style.minHeight = '0';
                chartCanvas.style.display = 'none';
                collapseBtn.textContent = 'â–¶';
                collapseBtn.title = 'Expand chart';
            }

            if (collapseBtn) {
                collapseBtn.addEventListener('click', () => {
                    chartCollapsed = !chartCollapsed;
                    localStorage.setItem('historyChartCollapsed', chartCollapsed.toString());

                    if (chartCollapsed) {
                        // Collapse
                        chartWrap.style.flex = '0 0 auto';
                        chartWrap.style.minHeight = '0';
                        chartCanvas.style.display = 'none';
                        collapseBtn.textContent = 'â–¶';
                        collapseBtn.title = 'Expand chart';
                    } else {
                        // Expand
                        chartWrap.style.flex = '1 1 auto';
                        chartWrap.style.minHeight = '140px';
                        chartCanvas.style.display = 'block';
                        collapseBtn.textContent = 'â–¼';
                        collapseBtn.title = 'Collapse chart';
                        // Redraw chart after expansion
                        setTimeout(() => { try { drawHistoryChart(); } catch {} }, 100);
                    }
                });
            }
        });

        // Throttle helpers and button state management
        // Rate limit helpers delegated to module

        // History list/detail/time delegates live in module

        function escapeHtml(str) {
            if (window.OverlayUtils && window.OverlayUtils.escapeHtml) {
                try { return window.OverlayUtils.escapeHtml(str); } catch {}
            }
            if (str == null) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        // Normalize currency labels to canonical keys used across filters/totals/UI
        function normalizeCurrency(c) {
            if (window.OverlayUtils && window.OverlayUtils.normalizeCurrency) {
                try { return window.OverlayUtils.normalizeCurrency(c); } catch {}
            }
            const raw = (c || '').toString().toLowerCase().trim();
            if (!raw) return '';
            // common shorthands and plurals
            const s = raw
                .replace(/\borbs?\b/g, '')
                .replace(/\borb\b/g, '')
                .replace(/\s+/g, ' ')
                .trim();
            if (/^(ex|exa|exalt|exalted)/.test(s)) return 'exalted';
            if (/^(div|divi|divine)/.test(s)) return 'divine';
            if (/^(ann|annul|annulment)/.test(s)) return 'annul';
            if (/^(c|chaos)/.test(s)) return 'chaos';
            if (/altar/.test(s)) return 'altar';
            return s;
        }

        // Delegations for modifier helpers now in module
        const _origCreateModItem = window.createModItem;
        if (typeof _origCreateModItem === 'function') {
          try { window.OverlayModifiers?.patchCreateModItem?.(); } catch {}
        }

// Character menu wiring
document.addEventListener('DOMContentLoaded', () => {
        if (characterTab) {
        characterTab.addEventListener('click', (e) => {
            e.stopPropagation();
                setActiveTab('characterTab');
                const vis = characterMenu && characterMenu.style.display === 'block';
                closeAllMenus();
                if (characterMenu) characterMenu.style.display = vis ? 'none' : 'block';
        });
        window.addEventListener('click', () => { if (characterMenu) characterMenu.style.display = 'none'; });
        if (characterMenu) characterMenu.addEventListener('click', (e) => { e.stopPropagation(); });
        if (characterMenu) characterMenu.querySelectorAll('.character-menu-item').forEach(item => {
            item.addEventListener('click', async () => {
                setActiveTab('characterTab');
                closeAllMenus();
                const action = item.getAttribute('data-action');
                if (characterMenu) characterMenu.style.display = 'none';
                // Switch to crafting/character view using single source of truth
                setView('crafting');
                if (action === 'quest-passives') {
                    if (window.OverlayQuestPassives?.show) { try { await window.OverlayQuestPassives.show(); } catch {} }
                    setHeader('Quest Passives');
                    
                } else if (action === 'keystones') {
                    await showKeystones();
                    setHeader('Keystones');
                    
                } else if (action === 'asc-passives') {
                    await showAscendancyPassives();
                    setHeader('Ascendancy Passives');
                    
                } else if (action === 'atlas-nodes') {
                    await showAtlasNodes();
                    setHeader('Atlas Nodes');
                } else if (action === 'gems') {
                    await showGems();
                    setHeader('Gems');
                } else if (action === 'glossar') {
                    try { await showGlossar(); } catch {}
                    setHeader('Glossar');
                }
            });
        });
    }

    // Dedicated unique focus event (from main showUniqueItem)
    if (window.electronAPI && typeof window.electronAPI.onShowUniqueItem !== 'function' && window.electronAPI.on === undefined) {
        // If preload exposes a generic on(channel, cb) you could hook that instead; here we assume a specific registration helper exists.
    }
    // Fallback: poll for a generic API and patch once available
    const attachUniqueHandler = () => {
        try {
            if (window.electronAPI && window.electronAPI.onShowUniqueItem && !window.__xilehudUniqueBound) {
                window.__xilehudUniqueBound = true;
                window.electronAPI.onShowUniqueItem((payload) => {
                    try {
                        // Ensure crafting view in Uniques mode
                        setView('crafting');
                        setHeader('Uniques');
                        // Reset scroll containers to top to avoid random offset
                        // Removed forced scroll reset to keep current position
                        // Attempt to render / show uniques panel if not yet loaded
                        const ensure = (attempts=5) => {
                            if (window.OverlayUniques && typeof window.OverlayUniques.show === 'function') {
                                try { showUniques(); } catch {}
                                // Removed auto highlight to prevent unintended scroll movement
                                return;
                            }
                            if (attempts>0) setTimeout(()=>ensure(attempts-1),120);
                        };
                        ensure();
                    } catch (e) { console.warn('unique focus failed', e); }
                });
            }
        } catch {}
        if (!window.__xilehudUniqueBound) setTimeout(attachUniqueHandler, 300);
    };
    attachUniqueHandler();
        if (itemsTab) {
        itemsTab.addEventListener('click', (e) => {
            e.stopPropagation();
                setActiveTab('itemsTab');
                const vis = itemsMenu && itemsMenu.style.display === 'block';
                closeAllMenus();
                if (itemsMenu) itemsMenu.style.display = vis ? 'none' : 'block';
        });
        window.addEventListener('click', () => { if (itemsMenu) itemsMenu.style.display = 'none'; });
        if (itemsMenu) itemsMenu.addEventListener('click', (e) => { e.stopPropagation(); });
        if (itemsMenu) itemsMenu.querySelectorAll('.items-menu-item').forEach(item => {
            item.addEventListener('click', async () => {
                setActiveTab('itemsTab');
                const tabHistEl = document.getElementById('tabHistory');
                if (tabHistEl) {
                    tabHistEl.classList.remove('active');
                    tabHistEl.setAttribute('style','background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px;');
                }
                closeAllMenus();
                const action = item.getAttribute('data-action');
                if (itemsMenu) itemsMenu.style.display = 'none';
                // Items render into crafting panel for consistency
                setView('crafting');
                if (action === 'uniques') {
                    await showUniques();
                    setHeader('Uniques');
                } else if (action === 'bases') {
                    await showBases();
                    setHeader('Bases');
                }
            });
        });
    }
    if (toolsTab) {
        toolsTab.addEventListener('click', (e) => {
            e.stopPropagation();
            setActiveTab('toolsTab');
            const vis = toolsMenu && toolsMenu.style.display === 'block';
            closeAllMenus();
            if (toolsMenu) toolsMenu.style.display = vis ? 'none' : 'block';
        });
        window.addEventListener('click', () => { if (toolsMenu) toolsMenu.style.display = 'none'; });
        if (toolsMenu) toolsMenu.addEventListener('click', (e) => { e.stopPropagation(); });
        if (toolsMenu) toolsMenu.querySelectorAll('.tools-menu-item').forEach(item => {
            item.addEventListener('click', async () => {
                setActiveTab('toolsTab');
                closeAllMenus();
                const action = item.getAttribute('data-action');
                if (toolsMenu) toolsMenu.style.display = 'none';
                if (action === 'regex') {
                    // Regex tool occupies crafting panel style container for now
                    setView('crafting');
                    if (window.OverlayRegex?.show) { try { await window.OverlayRegex.show(); } catch {} }
                    setHeader('Regex');
                }
            });
        });
    }
});

// Debounce mechanism to prevent category spam
let switchCategoryLocked = false;
let lastSwitchedCategory = '';
let lastSwitchTime = 0;

// Re-added after accidental removal: handles manual category selection in modifier panel
function switchCategory(){
    const select=document.getElementById('categorySelect');
    if(!select) return;
    const cat=select.value;
    if(!cat) return;
    
    // Debounce: if same category was just loaded within 2 seconds, skip
    const now = Date.now();
    if (cat === lastSwitchedCategory && (now - lastSwitchTime) < 2000) {
        console.log('Category switch debounced (same category within 2s):', cat);
        return;
    }
    
    // Lock: if already loading, queue and skip
    if (switchCategoryLocked) {
        console.log('Category switch locked (already loading):', cat);
        return;
    }
    
    switchCategoryLocked = true;
    lastSwitchedCategory = cat;
    lastSwitchTime = now;
    
    if(!window.electronAPI || !window.electronAPI.getModifierData) {
        switchCategoryLocked = false;
        return;
    }
    // Store current category globally for use in render functions
    window.currentModifierCategory = cat;
    // Ensure we're in Modifiers view; hide other panels and menus
    try {
        setView('modifiers');
        const tabModEl = document.getElementById('tabModifier');
        const tabHistEl = document.getElementById('tabHistory');
        if (tabModEl && tabHistEl) {
            tabModEl.classList.add('active');
            tabModEl.setAttribute('style','background: var(--accent-blue); color: #fff; border: 1px solid var(--accent-blue); border-radius: 4px; padding: 3px 8px; font-size: 12px;');
            tabHistEl.classList.remove('active');
            tabHistEl.setAttribute('style','background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px;');
        }
        // Close any open dropdown menus
        const craftingMenu = document.getElementById('craftingMenu'); if (craftingMenu) craftingMenu.style.display='none';
        const characterMenu = document.getElementById('characterMenu'); if (characterMenu) characterMenu.style.display='none';
        const itemsMenu = document.getElementById('itemsMenu'); if (itemsMenu) itemsMenu.style.display='none';
        // Hide legacy annoints panel if present
        const ann = document.getElementById('annointsPanel'); if (ann) ann.style.display='none';
    } catch {}
    // Fetch modifier data for chosen category and render a synthetic item context
    window.electronAPI.getModifierData(cat).then(mods=>{
        if(!Array.isArray(mods)){
            console.warn('Category returned non-array', mods);
            switchCategoryLocked = false;
            throw new Error('invalid_data');
        }
        const data={
            item:{ name: cat.replace(/_/g,' '), category: cat, baseType: cat.replace(/_/g,' '), itemClass: cat.replace(/_/g,' ') },
            modifiers: mods
        };
    // Apply mechanics post-processing via module (strongbox/logbook formatting, flags)
    try { window.OverlayModifiers?.mechanicsPostProcess?.(data); } catch {}
    window.originalData=data;
    renderCategoryDetail(data);
    try { setHeader('Modifier', cat.replace(/_/g,' ')); } catch {}
    switchCategoryLocked = false; // Unlock after successful load
    }).catch(err=>{
        console.error('switchCategory error', err);
        const content=document.getElementById('content');
        if(content) content.innerHTML=`<div class="no-mods" style="color:var(--accent-red);">Failed to load category (${err?.message||'error'})</div>`;
        switchCategoryLocked = false; // Unlock after error
    });
}

// ===== Essences Panel delegated to module =====
// (Removed duplicate extended crafting menu handler; actions are wired above.)

// ===== Catalysts delegated to module =====

// ===== Socketables delegated to module =====

// ===== Uniques (Items tab) now delegated to module (see top-level wrappers) =====

// ===== Bases (Items tab) now delegated to module (see top-level wrappers) =====

// ===== Omens delegated to module =====

// ===== Glossar (inline removed; delegated via wrappers defined above) =====

// ===== Glossar (inline removed; delegated via wrappers defined above) =====

// ===== Keystones (Character submenu) =====
async function showKeystones(){
    window.__lastPanel='keystones';
    prepareCharacterPanel('Keystones');
    craftingPanelEl.innerHTML='<div class="no-mods">Loading...</div>';
    try{
        const data = await window.electronAPI.getKeystones();
        if(!data || data.error){ craftingPanelEl.innerHTML=`<div style="color:var(--accent-red);">Failed to load Keystones (${data?.error||'unknown'})</div>`; return; }
        renderKeystones(data.keystones||[]);
    }catch(e){ craftingPanelEl.innerHTML='<div style="color:var(--accent-red);">Exception loading Keystones</div>'; }
}
// ===== Ascendancy Passives (Character submenu) =====
async function showAscendancyPassives(){
    window.__lastPanel='asc_passives';
    prepareCharacterPanel('Ascendancy Passives');
    craftingPanelEl.innerHTML='<div class="no-mods">Loading...</div>';
    try {
        const data = await window.electronAPI.getAscendancyPassives();
        if(!data || data.error){ craftingPanelEl.innerHTML=`<div style="color:var(--accent-red);">Failed to load Ascendancy Passives (${data?.error||'unknown'})</div>`; return; }
        renderAscendancyPassives(data.passives||[]);
    } catch(e){ craftingPanelEl.innerHTML='<div style="color:var(--accent-red);">Exception loading Ascendancy Passives</div>'; }
}
function renderAscendancyPassives(list){
    const panel=craftingPanelEl; if(!panel) return;
    panel.innerHTML=`<div class='page-inner'><div style='display:flex; gap:6px; align-items:center; margin-bottom:8px;'>
        <input id='ascSearch' type='text' placeholder='Search ascendancy passives...' style='flex:1; padding:4px 8px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:12px;'>
        <button id='ascClear' class='pin-btn' style='padding:4px 8px;'>Clear</button>
    </div>
    <div id='ascClassFilters' style='display:flex; flex-wrap:wrap; gap:6px; margin:-2px 0 8px; justify-content:center; width:100%;'></div>
    <div id='ascWrap' style='display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:10px;'></div></div>`;
    const searchEl=panel.querySelector('#ascSearch');
    const clearBtn=panel.querySelector('#ascClear');
    const filterWrap=panel.querySelector('#ascClassFilters');
    const wrap=panel.querySelector('#ascWrap');
    const classes = Array.from(new Set(list.map(p=>p.ascendancy).filter(Boolean))).sort();
    const selected = new Set();
    function chipCss(active){ return `padding:3px 8px; font-size:11px; border-radius:999px; cursor:pointer; border:1px solid var(--border-color); background:${active?'var(--accent-blue)':'var(--bg-tertiary)'}; color:${active?'#fff':'var(--text-primary)'};`; }
    function renderFilters(){ if(!filterWrap) return; filterWrap.innerHTML=''; classes.forEach(c=>{ const active=selected.has(c); const btn=document.createElement('button'); btn.textContent=c; btn.style.cssText=chipCss(active); btn.addEventListener('click',()=>{ if(active) selected.delete(c); else selected.add(c); build(searchEl.value||''); renderFilters(); }); filterWrap.appendChild(btn); }); if(selected.size){ const reset=document.createElement('button'); reset.textContent='Reset'; reset.style.cssText='padding:3px 8px; font-size:11px; border-radius:999px; cursor:pointer; background:var(--accent-red); color:#fff; border:1px solid var(--accent-red);'; reset.addEventListener('click',()=>{ selected.clear(); build(''); renderFilters(); }); filterWrap.appendChild(reset);} }
    function highlight(s){ return (s||"")
       .replace(/(\d+\s*[â€“-]\s*\d+)/g,'<span class="mod-value">$1</span>')
       .replace(/(?<![A-Za-z0-9>])([+\-]?\d+)(?![A-Za-z0-9<])/g,'<span class="mod-value">$1</span>')
       .replace(/(\d+%)/g,'<span class="mod-value">$1</span>'); }
    function matchesClass(p){ if(!selected.size) return true; return selected.has(p.ascendancy); }
    function build(filter=''){
        if(!wrap) return; wrap.innerHTML='';
        const f=filter.toLowerCase();
        const filtered = list.filter(p=>{ const blob=`${p.name} ${(p.explicitMods||[]).join(' ')}`.toLowerCase(); const searchOk = !f || blob.includes(f); return searchOk && matchesClass(p); });
        filtered.forEach(p=>{
            const card=document.createElement('div');
            card.style.background='var(--bg-card)';
            card.style.border='1px solid var(--border-color)';
            card.style.borderRadius='6px';
            card.style.padding='6px';
            card.style.display='flex';
            card.style.flexDirection='column';
            card.style.gap='4px';
            // Clean mods: remove inline skill icons (grantsSkill) then highlight numbers
            const cleanedMods = (p.explicitMods||[]).map(m=> m.replace(/<img[^>]*grantsSkill[^>]*>/ig,'').replace(/<img[^>]*>/ig,'').trim()).filter(Boolean);
            const mods = cleanedMods.map(m=>highlight(m)).join('<br>');
            const _ap = getImagePath(p);
            const imgHtml = p.image || p.imageLocal ? `<img src='' data-orig-src='${_ap}' class='asc-img' style='width:46px; height:46px; object-fit:contain; flex:0 0 46px;'>` : '';
            const metaParts = [];
            if(p.ascendancy) metaParts.push(`<span style="background:var(--accent-blue); color:#fff; padding:2px 8px; border-radius:12px; font-size:11px; font-weight:600; letter-spacing:0.3px;">${p.ascendancy}</span>`);
            if(p.character) metaParts.push(`<span style="background:var(--bg-tertiary); color:var(--text-primary); padding:2px 8px; border-radius:12px; font-size:11px;">${p.character}</span>`);
            if(p.stack_current!=null && p.stack_max!=null) metaParts.push(`<span>Stack: ${p.stack_current} / ${p.stack_max}</span>`);
            card.innerHTML = `<div style='display:flex; gap:10px; align-items:flex-start;'>${imgHtml}<div style='display:flex; flex-direction:column; gap:6px; flex:1;'><div style='font-weight:600; font-size:13px;'>${p.name}</div><div style='display:flex; gap:6px; flex-wrap:wrap;'>${metaParts.join('')}</div><div style='font-size:11px;'>${mods}</div></div></div>`;
            wrap.appendChild(card);
        });
        const svg = "<svg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'><rect width='30' height='30' rx='6' fill='#222'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='#555' font-size='9' font-family='sans-serif'>?</text></svg>";
        const placeholder = 'data:image/svg+xml;utf8,'+encodeURIComponent(svg);
    wrap.querySelectorAll('img.asc-img').forEach(img=>{ if(img._fb) return; img._fb=true; img.addEventListener('error',()=>{ img.src=placeholder; img.style.opacity='0.5'; img.style.filter='grayscale(1)'; },{once:true}); img.addEventListener('load',()=>{ if(img.src!==placeholder){ img.style.opacity='1'; img.style.filter='none'; } }, { once:true }); });
    }
    searchEl.addEventListener('input',()=>build(searchEl.value));
    clearBtn.addEventListener('click',()=>{ searchEl.value=''; selected.clear(); build(''); renderFilters(); searchEl.focus(); });
    build('');
    renderFilters();
}
function renderKeystones(list){
    const panel=craftingPanelEl; if(!panel) return;
    panel.innerHTML=`<div class='page-inner'><div style='display:flex; gap:6px; align-items:center; margin-bottom:8px;'>
        <input id='keystoneSearch' type='text' placeholder='Search keystones...' style='flex:1; padding:4px 8px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:12px;'>
        <button id='keystoneClear' class='pin-btn' style='padding:4px 8px;'>Clear</button>
    </div>
    <div id='keystoneTagFilters' style='display:flex; flex-wrap:wrap; gap:6px; margin:-2px 0 8px; justify-content:center; width:100%;'></div>
    <div id='keystoneWrap' style='display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:10px; align-items:stretch;'></div></div>`;
    // Don't set inline display:none - let CSS handle visibility via body classes
    const searchEl=panel.querySelector('#keystoneSearch');
    const clearBtn=panel.querySelector('#keystoneClear');
    const tagWrap=panel.querySelector('#keystoneTagFilters');
    const wrap=panel.querySelector('#keystoneWrap');
    // Tag coloring helpers
    function tagRGB(tag){ const t=(tag||'').toLowerCase();
        if(t==='fire' || t==='life') return [220,68,61];
        if(t==='cold' || t==='mana') return [66,165,245];
        if(t==='lightning') return [255,213,79];
        if(t==='chaos' || t==='minion') return [156,39,176];
        if(t==='energy shield' || t==='es') return [38,198,218];
        if(t==='defences' || t==='armour' || t==='armor') return [109,76,65];
        if(t==='evasion') return [46,125,50];
        if(t==='resistances') return [255,112,67];
        if(t==='projectile') return [255,179,0];
        if(t==='area') return [171,71,188];
        if(t==='critical' || t==='crit') return [255,179,0];
        if(t==='spell') return [92,107,192];
        if(t==='attack') return [121,85,72];
        if(t==='damage' || t==='ailments' || t==='mechanics') return [96,125,139];
        if(t==='movement' || t==='attack speed' || t==='speed') return [67,160,71];
        if(t==='elemental') return [255,152,0];
        return [120,144,156]; }
    function chipCss(tag, active){ const [r,g,b]=tagRGB(tag); const bg = active? `rgba(${r},${g},${b},0.9)` : `rgba(${r},${g},${b},0.22)`; const border=`rgba(${r},${g},${b},0.6)`; const luma=0.2126*r+0.7152*g+0.0722*b; const color = active ? (luma>180? '#000':'#fff') : 'var(--text-primary)'; return `border:1px solid ${border}; background:${bg}; color:${color};`; }
    // Curated tag set same as Annoints
    const curatedTags = ['Damage','Ailments','Attributes','Energy Shield','Defences','Life','Mana','Fire','Cold','Lightning','Chaos','Resistances','Projectile','Area','Critical','Spell','Attack','Minion','Mechanics'];
    const selected = new Set();
    // Derive tags from keystone text
    function deriveTags(k){ const text=`${k.name||''} ${String(k.description||'')}`; const tags=new Set();
        if(/Damage/i.test(text)) tags.add('Damage');
        if(/Ailment|Bleed|Ignite|Chill|Freeze|Shock|Poison|Stun|Electrocute/i.test(text)) tags.add('Ailments');
        if(/Attribute|Strength|Dexterity|Intelligence/i.test(text)) tags.add('Attributes');
        if(/Energy Shield|\bES\b/i.test(text)) tags.add('Energy Shield');
        if(/Armour|Armor|Evasion/i.test(text)) tags.add('Defences');
        if(/\bLife\b/i.test(text)) tags.add('Life');
        if(/\bMana\b/i.test(text)) tags.add('Mana');
        if(/\bFire\b/i.test(text)) tags.add('Fire');
        if(/\bCold\b/i.test(text)) tags.add('Cold');
        if(/Lightning|Electrocute/i.test(text)) tags.add('Lightning');
        if(/\bChaos\b/i.test(text)) tags.add('Chaos');
        if(/Resist/i.test(text)) tags.add('Resistances');
        if(/Projectile/i.test(text)) tags.add('Projectile');
        if(/\bArea\b/i.test(text)) tags.add('Area');
        if(/Critical/i.test(text)) tags.add('Critical');
        if(/Cast|Spell/i.test(text)) tags.add('Spell');
        if(/\bAttack\b/i.test(text)) tags.add('Attack');
        if(/Minion/i.test(text)) tags.add('Minion');
        if(/Trap|Totem|Trigger/i.test(text)) tags.add('Mechanics');
        return [...tags]; }
    // Precompute item tags and counts
    list.forEach(k=>{ k.__tags = deriveTags(k); });
    const tagCounts = Object.fromEntries(curatedTags.map(t=>[t,0]));
    list.forEach(k=> (k.__tags||[]).forEach(t=>{ if(tagCounts[t]!=null) tagCounts[t]++; }));
    function renderTagFilters(){ if(!tagWrap) return; tagWrap.innerHTML=''; curatedTags.forEach(tag=>{ const active=selected.has(tag.toLowerCase()); const btn=document.createElement('button'); const count=tagCounts[tag]||0; btn.className='key-tag'; btn.setAttribute('data-tag', tag.toLowerCase()); btn.textContent = count? `${tag} (${count})` : tag; btn.style.cssText = `padding:3px 8px; font-size:11px; border-radius:999px; cursor:pointer; ${chipCss(tag, active)}`; btn.addEventListener('click',()=>{ if(active) selected.delete(tag.toLowerCase()); else selected.add(tag.toLowerCase()); build(searchEl.value||''); renderTagFilters(); }); tagWrap.appendChild(btn); }); if(selected.size){ const reset=document.createElement('button'); reset.textContent='Reset'; reset.style.cssText='padding:3px 8px; font-size:11px; border-radius:999px; cursor:pointer; background:var(--accent-red); color:#fff; border:1px solid var(--accent-red);'; reset.addEventListener('click',()=>{ selected.clear(); build(''); renderTagFilters(); }); tagWrap.appendChild(reset); } }
    function matchTags(k){ if(!selected.size) return true; const lc=(k.__tags||[]).map(t=>t.toLowerCase()); return [...selected].every(t=> lc.includes(t)); }
    function build(filter=''){
        wrap.innerHTML='';
        const f=filter.toLowerCase();
        list.filter(k=>{ const matchesSearch = !f || k.name.toLowerCase().includes(f) || (k.description||'').toLowerCase().includes(f); return matchesSearch && matchTags(k); }).forEach(k=>{
            const card=document.createElement('div');
            card.className='keystone-card';
            card.style.background='var(--bg-card)';
            card.style.border='1px solid var(--border-color)';
            card.style.borderRadius='6px';
            card.style.padding='6px';
            card.style.display='flex';
            card.style.flexDirection='column';
            card.style.gap='4px';
            card.style.height='100%';
            const kp = getImagePath(k);
            const imgHtml = k.image || k.imageLocal ? `<img src='' data-orig-src='${kp}' class='keystone-img' style='width:30px; height:30px; object-fit:contain;'>` : `<img src='' class='keystone-img' style='width:30px; height:30px; object-fit:contain;'>`;
            card.innerHTML=`<div style='display:flex; gap:6px; align-items:center;'>${imgHtml}<div style='font-weight:600;'>${k.name}</div></div><div style='font-size:11px;'>${k.description||''}</div>`;
            wrap.appendChild(card);
        });
        // Image fallback placeholder
        const placeholderSvg = `data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'><rect width='30' height='30' rx='6' fill='#222'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='#555' font-size='9' font-family='sans-serif'>?</text></svg>`)}`;
        wrap.querySelectorAll('img.keystone-img').forEach(function(img){
            if(img._fb) return; img._fb=true; img.loading= img.loading || 'lazy'; img.decoding='async';
            img.addEventListener('error', function(){ img.src=placeholderSvg; img.style.opacity='0.5'; img.style.filter='grayscale(1)'; });
            img.addEventListener('load', function(){ if(img.src!==placeholderSvg){ img.style.opacity='1'; img.style.filter='none'; }});
        });
    }
    searchEl.addEventListener('input',()=>build(searchEl.value));
    clearBtn.addEventListener('click',()=>{searchEl.value=''; selected.clear(); build(''); renderTagFilters(); searchEl.focus();});
    build('');
    renderTagFilters();
}
    // ===== Atlas Nodes (Character submenu) =====
async function showAtlasNodes(){
    window.__lastPanel='atlas_nodes';
    prepareCharacterPanel('Atlas Nodes');
    craftingPanelEl.innerHTML='<div class="no-mods">Loading...</div>';
    try{
        const data = await window.electronAPI.getAtlasNodes();
        if(!data || data.error){ craftingPanelEl.innerHTML=`<div style="color:var(--accent-red);">Failed to load Atlas Nodes (${data?.error||'unknown'})</div>`; return; }
        renderAtlasNodes(data.nodes||[]);
    }catch(e){ craftingPanelEl.innerHTML='<div style="color:var(--accent-red);">Exception loading Atlas Nodes</div>'; }
}
function renderAtlasNodes(list){
    const panel=craftingPanelEl; if(!panel) return;
    panel.innerHTML=`<div class='page-inner'><div style='display:flex; gap:6px; align-items:center; margin-bottom:8px;'>
        <input id='atlasSearch' type='text' placeholder='Search atlas nodes...' style='flex:1; padding:4px 8px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:12px;'>
        <button id='atlasClear' class='pin-btn' style='padding:4px 8px;'>Clear</button>
    </div>
    <div id='atlasTagFilters' style='display:flex; flex-wrap:wrap; gap:6px; margin:-2px 0 8px; justify-content:center; width:100%;'></div>
    <div id='atlasWrap' style='display:grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap:10px;'></div></div>`;
    const searchEl=panel.querySelector('#atlasSearch');
    const clearBtn=panel.querySelector('#atlasClear');
    const tagWrap=panel.querySelector('#atlasTagFilters');
    const wrap=panel.querySelector('#atlasWrap');
    function tagRGB(tag){ const t=(tag||'').toLowerCase();
        if(t==='fire' || t==='life') return [220,68,61];
        if(t==='cold' || t==='mana') return [66,165,245];
        if(t==='lightning') return [255,213,79];
        if(t==='chaos' || t==='minion') return [156,39,176];
        if(t==='energy shield' || t==='es') return [38,198,218];
        if(t==='defences' || t==='armour' || t==='armor') return [109,76,65];
        if(t==='evasion') return [46,125,50];
        if(t==='resistances') return [255,112,67];
        if(t==='projectile') return [255,179,0];
        if(t==='area') return [171,71,188];
        if(t==='critical' || t==='crit') return [255,179,0];
        if(t==='spell') return [92,107,192];
        if(t==='attack') return [121,85,72];
        if(t==='damage' || t==='ailments' || t==='mechanics') return [96,125,139];
        if(t==='movement' || t==='attack speed' || t==='speed') return [67,160,71];
        if(t==='elemental') return [255,152,0];
        return [120,144,156]; }
    function chipCss(tag, active){ const [r,g,b]=tagRGB(tag); const bg = active? `rgba(${r},${g},${b},0.9)` : `rgba(${r},${g},${b},0.22)`; const border=`rgba(${r},${g},${b},0.6)`; const luma=0.2126*r+0.7152*g+0.0722*b; const color = active ? (luma>180? '#000':'#fff') : 'var(--text-primary)'; return `border:1px solid ${border}; background:${bg}; color:${color};`; }
    // Requested tag set for Atlas Nodes
    const curatedTags = [
        'quantity','rarity','explicit','prefix','suffix','delirium','breach','expedition','runic','remnants','spirit','ritual','azmeri','essence','strongbox','shrine','boss','waystone','rogue','biome','monster pack size','rare','magic'
    ];
    const selected = new Set();
    function deriveTags(n){ const text=`${n.name||''} ${String(n.description||'')}`.toLowerCase(); const tags=new Set();
        if(/\bquantity\b|item\s+quantity/i.test(text)) tags.add('quantity');
        if(/\brarity\b|item\s+rarity/i.test(text)) tags.add('rarity');
    if(/\bexplicit\b/i.test(text)) tags.add('explicit');
    if(/\bprefix(es)?\b/i.test(text)) tags.add('prefix');
        if(/\bsuffix(es)?\b/i.test(text)) tags.add('suffix');
        if(/\bdelirium\b/i.test(text)) tags.add('delirium');
        if(/\bbreach\b/i.test(text)) tags.add('breach');
        if(/\bexpedition\b/i.test(text)) tags.add('expedition');
        if(/\brunic\b/i.test(text)) tags.add('runic');
        if(/\bremnants?\b/i.test(text)) tags.add('remnants');
        if(/\bspirit\b/i.test(text)) tags.add('spirit');
        if(/\britual\b/i.test(text)) tags.add('ritual');
        if(/\bazmeri\b/i.test(text)) tags.add('azmeri');
        if(/\bessence\b/i.test(text)) tags.add('essence');
        if(/\bstrongbox\b/i.test(text)) tags.add('strongbox');
        if(/\bshrine\b/i.test(text)) tags.add('shrine');
        if(/\bboss\b/i.test(text)) tags.add('boss');
        if(/\bwaystone\b/i.test(text)) tags.add('waystone');
        if(/\brogue\b/i.test(text)) tags.add('rogue');
        if(/\bbiome\b/i.test(text)) tags.add('biome');
        if(/monster\s+pack\s+size/i.test(text)) tags.add('monster pack size');
        if(/\brare\b/i.test(text)) tags.add('rare');
        if(/\bmagic\b/i.test(text)) tags.add('magic');
        return [...tags]; }
    list.forEach(n=>{ n.__tags = deriveTags(n); });
    const tagCounts = Object.fromEntries(curatedTags.map(t=>[t,0]));
    list.forEach(n=> (n.__tags||[]).forEach(t=>{ if(tagCounts[t]!=null) tagCounts[t]++; }));
    function renderTagFilters(){ if(!tagWrap) return; tagWrap.innerHTML=''; curatedTags.forEach(tag=>{ const active=selected.has(tag.toLowerCase()); const btn=document.createElement('button'); const count=tagCounts[tag]||0; btn.className='key-tag'; btn.setAttribute('data-tag', tag.toLowerCase()); btn.textContent = count? `${tag} (${count})` : tag; btn.style.cssText = `padding:3px 8px; font-size:11px; border-radius:999px; cursor:pointer; ${chipCss(tag, active)}`; btn.addEventListener('click',()=>{ if(active) selected.delete(tag.toLowerCase()); else selected.add(tag.toLowerCase()); build(searchEl.value||''); renderTagFilters(); }); tagWrap.appendChild(btn); }); if(selected.size){ const reset=document.createElement('button'); reset.textContent='Reset'; reset.style.cssText='padding:3px 8px; font-size:11px; border-radius:999px; cursor:pointer; background:var(--accent-red); color:#fff; border:1px solid var(--accent-red);'; reset.addEventListener('click',()=>{ selected.clear(); build(''); renderTagFilters(); }); tagWrap.appendChild(reset); } }
    function matchTags(n){ if(!selected.size) return true; const lc=(n.__tags||[]).map(t=>t.toLowerCase()); return [...selected].every(t=> lc.includes(t)); }
    function build(filter=''){
        wrap.innerHTML='';
        const f=filter.toLowerCase();
        list.filter(n=>{ const matchesSearch = !f || n.name.toLowerCase().includes(f) || (n.description||'').toLowerCase().includes(f); return matchesSearch && matchTags(n); }).forEach(n=>{
            const card=document.createElement('div');
            card.style.background='var(--bg-card)';
            card.style.border='1px solid var(--border-color)';
            card.style.borderRadius='6px';
            card.style.padding='8px';
            card.style.display='flex';
            card.style.flexDirection='column';
            card.style.gap='6px';
            card.style.height='100%';
            const ap=getImagePath(n);
            const title=`<div style='display:flex; align-items:center; gap:6px;'><img src='' data-orig-src='${ap}' class='atlas-img' style='width:28px; height:28px; object-fit:contain;'/><div style='font-weight:700; font-size:15px;'>${n.name}</div></div>`;
            const bodyHtml = (n.description_html || escapeHtml(n.description || '')).trim();
            const body = `<div style='font-size:12px; line-height:1.35;'>${bodyHtml}</div>`;
            card.innerHTML=title+body;
            wrap.appendChild(card);
        });
        // Add image fallback for atlas nodes
        const placeholderSvg = `data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' viewBox='0 0 28 28'><rect width='28' height='28' rx='6' fill='#222'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='#555' font-size='8' font-family='sans-serif'>?</text></svg>`)}`;
        wrap.querySelectorAll('img.atlas-img').forEach(function(img){
            if(img._fb) return; img._fb=true; img.loading='lazy'; img.decoding='async';
            img.addEventListener('error', function(){ img.src=placeholderSvg; img.style.opacity='0.5'; img.style.filter='grayscale(1)'; });
            img.addEventListener('load', function(){ if(img.src!==placeholderSvg){ img.style.opacity='1'; img.style.filter='none'; }});
        });
    }
    searchEl.addEventListener('input',()=>build(searchEl.value));
    clearBtn.addEventListener('click',()=>{ searchEl.value=''; build(''); searchEl.focus(); });
    // Prevent any stray anchor clicks inside list
    panel.addEventListener('click',(e)=>{ const target = e.target && ((e.target)); const a = target && target.closest ? target.closest('a') : null; if(a){ e.preventDefault(); e.stopPropagation(); }});
    renderTagFilters();
    build('');
}

// ===== Gems (Character submenu) =====
async function showGems(){
    window.__lastPanel='gems';
    prepareCharacterPanel('Gems');
    craftingPanelEl.innerHTML='<div class="no-mods">Loading...</div>';
    // Reset scroll position to top when showing gems (with delay to ensure content is rendered)
    setTimeout(() => {
        if (craftingPanelEl) craftingPanelEl.scrollTop = 0;
    }, 10);
    try{
        const data = await window.electronAPI.getGems();
        if(!data || data.error){ craftingPanelEl.innerHTML=`<div style=\"color:var(--accent-red);\">Failed to load Gems (${data?.error||'unknown'})</div>`; return; }
        renderGems(data.gems||{});
    }catch(e){ craftingPanelEl.innerHTML='<div style=\"color:var(--accent-red);\">Exception loading Gems</div>'; }
}
function renderGems(groups){
    const panel=craftingPanelEl; if(!panel) return;
    const order=[["skill","Skill Gems"],["support","Support Gems"],["spirit","Spirit Gems"],["lineage","Lineage Supports"]];
    const skillTags=new Set();
    order.forEach(([key, label]) => { (groups[key]||[]).forEach(g => { (g.tags||[]).filter(Boolean).forEach(tag => skillTags.add(tag)); }); });
    const sortedTags=[...skillTags].sort((a,b)=>a.localeCompare(b));
    const tagCounts = {};
    order.forEach(([key])=>{ (groups[key]||[]).forEach(g=>{ (g.tags||[]).forEach(t=>{ tagCounts[t] = (tagCounts[t]||0)+1; }); }); });
    panel.innerHTML=`<div style='display:flex; gap:6px; align-items:center; margin-bottom:6px;'>
        <input id='gemSearch' type='text' placeholder='Search gems...' style='flex:1; padding:4px 8px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:12px;'>
        <button id='gemClear' class='pin-btn' style='padding:4px 8px;'>Clear</button>
    </div>
    <div style='display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:4px;'>
    <div id='gemTagFilters' style='display:flex; flex-wrap:wrap; gap:4px; justify-content:center; width:100%;'></div>
      <button id='gemImgLogBtn' title='Show recent image request log' style='padding:2px 6px; font-size:11px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; cursor:pointer;'>Img Log</button>
    </div>
    <div id='gemImgDiag' style='display:none; flex-direction:column; gap:4px; margin-bottom:8px;'></div>
    <div id='gemSections' style='display:flex; flex-direction:column; gap:14px;'></div>`;
    const searchEl=panel.querySelector('#gemSearch');
    const clearBtn=panel.querySelector('#gemClear');
    const container=panel.querySelector('#gemSections');
    const tagWrap=panel.querySelector('#gemTagFilters');
    const imgDiag=panel.querySelector('#gemImgDiag');
    const imgLogBtn=panel.querySelector('#gemImgLogBtn');
    if(imgLogBtn) imgLogBtn.style.display='none';
    const selectedTags=new Set();
    function tagRGB(tag){ const t=(tag||'').toLowerCase();
        if(t==='fire' || t==='life') return [220,68,61];
        if(t==='cold' || t==='mana') return [66,165,245];
        if(t==='lightning') return [255,213,79];
        if(t==='chaos' || t==='minion') return [156,39,176];
        if(t==='energy shield' || t==='es') return [38,198,218];
        if(t==='armour' || t==='armor' || t==='defences') return [109,76,65];
        if(t==='evasion') return [46,125,50];
        if(t==='resistances' || t==='resist') return [255,112,67];
        if(t==='projectile') return [255,179,0];
        if(t==='area') return [171,71,188];
        if(t==='critical' || t==='crit') return [255,179,0];
        if(t==='spell') return [92,107,192];
        if(t==='attack') return [121,85,72];
        if(t==='damage' || t==='ailments' || t==='mechanics') return [96,125,139];
        if(t==='movement' || t==='attack speed' || t==='speed') return [67,160,71];
        if(t==='elemental') return [255,152,0];
        return [120,144,156]; }
    function chipCss(tag, active){ const [r,g,b]=tagRGB(tag); const bg = active? `rgba(${r},${g},${b},0.9)` : `rgba(${r},${g},${b},0.22)`; const border=`rgba(${r},${g},${b},0.6)`; const luma=0.2126*r+0.7152*g+0.0722*b; const color = active ? (luma>180? '#000':'#fff') : 'var(--text-primary)'; return `border:1px solid ${border}; background:${bg}; color:${color};`; }
    function renderTagFilters(){ if(!tagWrap) return; tagWrap.innerHTML=''; sortedTags.forEach(tag=>{ const btn=document.createElement('div'); const active=selectedTags.has(tag); const count = tagCounts[tag]||0; btn.textContent = count ? `${tag} (${count})` : tag; btn.style.cssText = `cursor:pointer; user-select:none; padding:2px 6px; font-size:11px; border-radius:999px; ${chipCss(tag, active)}`; btn.addEventListener('click',()=>{ active?selectedTags.delete(tag):selectedTags.add(tag); build(searchEl.value||''); renderTagFilters(); }); tagWrap.appendChild(btn); }); if(selectedTags.size){ const reset=document.createElement('div'); reset.textContent='Reset'; reset.style.cursor='pointer'; reset.style.userSelect='none'; reset.style.padding='2px 6px'; reset.style.fontSize='11px'; reset.style.border='1px solid var(--accent-red)'; reset.style.borderRadius='999px'; reset.style.background='var(--accent-red)'; reset.style.color='#fff'; reset.addEventListener('click',()=>{ selectedTags.clear(); build(searchEl.value||''); renderTagFilters(); }); tagWrap.appendChild(reset); } }
    function gemMatches(g){ if(selectedTags.size===0) return true; const desc=(g.description||'').toLowerCase(); return [...selectedTags].every(t=> (g.tags&&g.tags.includes(t)) || desc.includes(t.toLowerCase())); }
    function build(filter=''){
        container.innerHTML='';
        const f=filter.toLowerCase();
        order.forEach(([key,label])=>{
            const list=(groups[key]||[]).filter(g=>{
                const matchesSearch=!f || g.name.toLowerCase().includes(f) || (g.type||'').toLowerCase().includes(f) || (g.description||'').toLowerCase().includes(f);
                return matchesSearch && gemMatches(g);
            });
            if(!list.length) return;
            const section=document.createElement('div');
            section.innerHTML=`<div style='font-weight:600; font-size:14px; margin-bottom:4px;'>${label} (${list.length})</div>`;
            const wrap=document.createElement('div'); wrap.style.display='grid'; wrap.style.gridTemplateColumns='repeat(auto-fit, minmax(230px, 1fr))'; wrap.style.gap='10px';
            list.forEach(g=>{
                const card=document.createElement('div');
                card.style.background='var(--bg-card)'; card.style.border='1px solid var(--border-color)'; card.style.borderRadius='6px'; card.style.padding='6px'; card.style.display='flex'; card.style.flexDirection='column'; card.style.gap='4px';
                const gp = getImagePath(g);
                const imgHtml = g.image || g.imageLocal ?`<img class='gem-img' src='' data-orig-src='${gp}' loading='lazy' decoding='async' style='width:28px; height:28px; object-fit:contain;'>`:'';
                const base=`<div style='display:flex; gap:6px; align-items:center;'>${imgHtml}<div style='font-weight:600;'>${g.name}</div></div><div style='font-size:10px; color:var(--text-muted);'>${g.type||''}</div><div style='font-size:11px; max-height:120px; overflow:auto;'>${g.description||''}</div>`;
                const tagsRow = `<div style='font-size:10px; display:flex; flex-wrap:wrap; gap:4px;'>${(g.tags||[]).length? (g.tags||[]).map(t=>'<span style="background:var(--bg-tertiary); padding:2px 4px; border-radius:3px; line-height:1;">'+t+'</span>').join('') : '<span style="opacity:.5;">No tags</span>'}</div>`;
                card.innerHTML=base+tagsRow;
                wrap.appendChild(card);
            });
            section.appendChild(wrap); container.appendChild(section);
        });
        // Image fallback
                const placeholder='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><rect width="28" height="28" rx="4" fill="%23222"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="%23555" font-size="8" font-family="sans-serif">?</text></svg>';
                container.querySelectorAll('img.gem-img').forEach(img=>{
                    if(img._fb)return; img._fb=true; const orig=img.getAttribute('data-orig-src')||img.src; img.setAttribute('data-orig-src', orig);
                    img.addEventListener('error',()=>{
                        if(!img.dataset.retry){ img.dataset.retry='1'; const bust=orig+(orig.includes('?')?'&':'?')+'r='+Date.now(); img.src=bust; return; }
                        img.src=placeholder; img.style.opacity='0.55'; img.style.filter='grayscale(1)';
                        try { (window).__imageErrorEvents = (window).__imageErrorEvents || []; (window).__imageErrorEvents.push({ ts:Date.now(), phase:'failed', src:orig }); } catch {}
                    });
                });
    }
    searchEl.addEventListener('input',()=>build(searchEl.value));
    clearBtn.addEventListener('click',()=>{ searchEl.value=''; build(''); searchEl.focus(); });
        imgLogBtn.addEventListener('click', async ()=>{
                try {
                    const log = await window.electronAPI.getImageLog?.();
                    if(!imgDiag)return; if(!log||!log.length){ imgDiag.style.display='flex'; imgDiag.innerHTML='<div style="font-size:11px; color:var(--text-muted);">No image log entries.</div>'; return; }
                    imgDiag.style.display='flex';
                    imgDiag.innerHTML = `<div style='font-size:11px; font-weight:600;'>Recent Image Requests (${log.length})</div>`+
                        `<div style='max-height:160px; overflow:auto; font-size:10px; line-height:1.25; background:var(--bg-tertiary); padding:4px; border:1px solid var(--border-color); border-radius:4px;'>`+
                        log.slice().reverse().map(e=>`<div style='margin-bottom:4px;'>${e.status?`<span style='color:${e.status>=200&&e.status<300?'#6fbf73':'var(--accent-red)'};'>${e.status}</span>`:`<span style='color:var(--accent-red);'>ERR</span>`} <span style='opacity:.7;'>${e.method}</span> <span>${e.url}</span>${e.error?`<div style='color:var(--accent-red);'>${e.error}</div>`:''}</div>`).join('')+
                        `</div>`;
                        // Attempt a targeted retry for 403 images (might succeed with new headers)
                                    const forbidden = (log||[]).filter(e=>e.status===403).map(e=>e.url);
                                    if(forbidden.length){
                                        const allImgs = Array.from(document.querySelectorAll('img.gem-img'));
                                        allImgs.forEach(function(img){
                                            var orig = img.getAttribute('data-orig-src') || img.src;
                                            if(forbidden.includes(orig) && !img.dataset.retry403){
                                                img.dataset.retry403='1';
                                                setTimeout(function(){ img.src = orig + (orig.includes('?')?'&':'?')+'reh='+Date.now(); }, 100);
                                            }
                                        });
                                    }
                } catch(err) {
                    if(imgDiag){ imgDiag.style.display='flex'; imgDiag.innerHTML='<div style="color:var(--accent-red); font-size:11px;">Failed to fetch image log</div>'; }
                }
        });
        build('');
        renderTagFilters();
    // Shared debug hotkey (Ctrl+Shift+I) to toggle gem img log button
    if(!window.__gemImgDebugHotkey){
        window.__gemImgDebugHotkey=true;
        window.addEventListener('keydown',function(e){
            if(e.ctrlKey && e.shiftKey && e.code==='KeyI'){
                if(imgLogBtn){ imgLogBtn.style.display = imgLogBtn.style.display==='none' ? '' : 'none'; }
            }
        });
    }
}

// --- Generic auto-resolve for bundled images (gems / atlas / ascendancy / keystones / bases / uniques) ---
// NEW SYSTEM: Images use imageLocal field with clean paths like "keystones/avatar_of_fire.webp"
// This resolver converts those to file:// URLs and also handles legacy URL-based images as fallback.
(function(){
    // Generic resolver for any <img data-orig-src> left unhandled by module-specific bindImageFallback.
    function resolveImg(img){
        if(!img || img.dataset._genericResolved) return;
        const orig = img.getAttribute('data-orig-src');
        if(!orig) return;
        // If already has a non-empty src, skip.
        if(img.getAttribute('src')) { return; }
        const finish = (u) => {
            if(!u) return;
            img.src = u;
            img.dataset._genericResolved = '1';
            // Clear any placeholder styling if set earlier
            requestAnimationFrame(()=>{ if(img.src && !/data:image\/svg/i.test(img.src)){ img.style.opacity='1'; img.style.filter='none'; } });
        };
        try {
            if(/^file:|^data:/.test(orig)) { return finish(orig); }
            if((window).bundledImages && (window).bundledImages.toFileUrl){ finish((window).bundledImages.toFileUrl(orig)); return; }
            if((window).electronAPI && (window).electronAPI.getBundledImagePath){
                (window).electronAPI.getBundledImagePath(orig).then(u=>{ if(!img.dataset._genericResolved && u) finish(u); });
                return;
            }
            // Last resort: try using orig directly (may 404, error handlers will catch)
            finish(orig);
        } catch {}
    }
    function scan(){ document.querySelectorAll('img[data-orig-src]').forEach(i=>{ if(!i.getAttribute('src')) resolveImg(i); }); }
    setTimeout(scan, 5);
    new MutationObserver(()=>scan()).observe(document.documentElement,{childList:true,subtree:true});
    document.addEventListener('DOMContentLoaded', scan);
})();

// Bottom resize handle wiring (vertical resize)
(function(){
    const handle = document.getElementById('resizeHandle');
    if (!handle || !window.electronAPI || typeof window.electronAPI.resizeOverlayHeight !== 'function') return;
    let startY = 0; let startH = 0; let dragging = false; let raf = 0;
    const onMove = (ev) => {
        if (!dragging) return;
        const dy = ev.clientY - startY;
        const target = Math.max(200, startH + dy);
        if (raf) cancelAnimationFrame(raf);
        raf = requestAnimationFrame(()=>{ try { window.electronAPI.resizeOverlayHeight(target); } catch {} });
    };
    const onUp = () => {
        dragging = false;
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
    };
    handle.addEventListener('mousedown', (ev)=>{
        ev.preventDefault(); ev.stopPropagation();
        startY = ev.clientY; startH = window.innerHeight; dragging = true;
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
    });
})();
                </script>
                <script>
                // IPC glue for tray / main-process actions
                (function(){
                    if (window.electronAPI) {
                        try {
                            window.electronAPI.onSetActiveTab?.((tab)=>{
                                if (tab === 'modifiers') {
                                    if (!featureAvailability.modifiers) return;
                                    const modTab = document.getElementById('tabModifier');
                                    if (!modTab || window.getComputedStyle(modTab).display === 'none') return;
                                    const histTab = document.getElementById('tabHistory');
                                    const contentMod = document.getElementById('content');
                                    const historyContainer = document.getElementById('historyContainer');
                                    modTab.classList.add('active');
                                    histTab?.classList.remove('active');
                                    if (contentMod) contentMod.style.display='block';
                                    if (historyContainer) historyContainer.style.display='none';
                                }
                                if (tab === 'crafting' || tab === 'character') {
                                    if (!featureAvailability.crafting) return;
                                    const craftBtn = document.getElementById('craftingTab');
                                    craftBtn?.click?.();
                                }
                                if (tab === 'history') {
                                    if (!featureAvailability.history) return;
                                    const histTab = document.getElementById('tabHistory');
                                    if (!histTab || window.getComputedStyle(histTab).display === 'none') return;
                                    const modTab = document.getElementById('tabModifier');
                                    const contentMod = document.getElementById('content');
                                    const historyContainer = document.getElementById('historyContainer');
                                    modTab?.classList.remove('active');
                                    histTab.classList.add('active');
                                    if (contentMod) contentMod.style.display='none';
                                    if (historyContainer) historyContainer.style.display='flex';
                                    try { setHeader('Merchant History'); } catch {}
                                }
                            });
                            window.electronAPI.onInvokeAction?.((action)=>{
                                if (action === 'regex') {
                                    try { if (window.OverlayRegex?.show) { window.OverlayRegex.show(); setHeader('Regex'); } } catch {}
                                }
                                if (action === 'merchant-history') {
                                    if (!featureAvailability.history) return;
                                    const histBtn = document.getElementById('tabHistory');
                                    histBtn?.click?.();
                                }
                                if (action === 'socketables') {
                                    try {
                                        closeAllMenus(); // Close the crafting dropdown menu
                                        if (window.OverlaySocketables?.show) { 
                                            window.OverlaySocketables.show(); 
                                            setHeader('Socketables'); 
                                        } 
                                    } catch {}
                                }
                                if (action === 'gems') {
                                    try {
                                        setActiveTab('characterTab');
                                        setView('crafting'); // Still use crafting view (shares craftingPanel div)
                                        showGems();
                                        setHeader('Gems');
                                    } catch {}
                                }
                            });
                            // Respond to category selection from main
                            window.electronAPI.onSetActiveCategory?.(async (cat)=>{
                                try {
                                    const normalized = String(cat || '').toLowerCase();
                                    if (normalized === 'socketables') {
                                        closeAllMenus();
                                        setActiveTab('craftingTab');
                                        setView('crafting');
                                        try { await showSocketables(); } catch {}
                                        setHeader('Socketables');
                                        return;
                                    }
                                    const select = document.getElementById('categorySelect');
                                    if (select) { select.value = cat; select.dispatchEvent(new Event('change')); }
                                } catch {}
                            });
                            // Handle history popout refresh requests
                            window.electronAPI.onRequestHistoryPopoutRefresh?.(async ()=>{
                                try {
                                    if (typeof window.OverlayHistory?.onPopoutRefresh === 'function') {
                                        await window.OverlayHistory.onPopoutRefresh();
                                    }
                                } catch (e) {
                                    console.error('Failed to handle popout refresh:', e);
                                }
                            });
                        } catch {}
                    }
                })();
                </script>
</html>